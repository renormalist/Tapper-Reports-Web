<div class="artemismanual">
<h1 class="settitle">ARTEMIS Manual</h1>
<div class="node">
<p><hr>
<a name="Top"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Synopsis">Synopsis</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<ul class="menu">
<li><a accesskey="1" href="#Synopsis">Synopsis</a>
<li><a accesskey="2" href="#Technical-Infrastructure">Technical Infrastructure</a>
<li><a accesskey="3" href="#Test-Protocol">Test Protocol</a>
<li><a accesskey="4" href="#Test-Suite-Wrappers">Test Suite Wrappers</a>
<li><a accesskey="5" href="#Preconditions">Preconditions</a>
<li><a accesskey="6" href="#Commandline">Commandline</a>
<li><a accesskey="7" href="#Web-User-Interface">Web User Interface</a>
<li><a accesskey="8" href="#Reports-API">Reports API</a>
<li><a accesskey="9" href="#Complete-Use_002dCases">Complete Use-Cases</a>
<li><a href="#Artemis-Development">Artemis Development</a>
</ul>

<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Synopsis" href="#Synopsis">1 Synopsis</a>
<li><a name="toc_Technical-Infrastructure" href="#Technical-Infrastructure">2 Technical Infrastructure</a>
<ul>
<li><a href="#Technical-Infrastructure">2.1 Adding a new host into automation</a>
<ul>
<li><a href="#Technical-Infrastructure">2.1.1 Make machine remote restartable</a>
<li><a href="#Technical-Infrastructure">2.1.2 Make machine PXE boot aware</a>
<li><a href="#Technical-Infrastructure">2.1.3 Add host to the hardware database</a>
<li><a href="#Technical-Infrastructure">2.1.4 Optionally: enable &lsquo;<samp><span class="samp">temare</span></samp>&rsquo; to generate tests for this host</a>
</li></ul>
</li></ul>
<li><a name="toc_Test-Protocol" href="#Test-Protocol">3 Test Protocol</a>
<ul>
<li><a href="#Test-Protocol">3.1 Test Anything Protocol (TAP)</a>
<li><a href="#Test-Protocol">3.2 Tutorial</a>
<ul>
<li><a href="#Test-Protocol">3.2.1 Just plan and success</a>
<li><a href="#Test-Protocol">3.2.2 Succession numbers</a>
<li><a href="#Test-Protocol">3.2.3 Test descriptions</a>
<li><a href="#Test-Protocol">3.2.4 Mark tests as TODO</a>
<li><a href="#Test-Protocol">3.2.5 Comment TODO tests with reason</a>
<li><a href="#Test-Protocol">3.2.6 Mark tests as SKIP (with reason)</a>
<li><a href="#Test-Protocol">3.2.7 Diagnostics</a>
<li><a href="#Test-Protocol">3.2.8 YAML Diagnostics</a>
<li><a href="#Test-Protocol">3.2.9 Headers for ARTEMIS</a>
<li><a href="#Test-Protocol">3.2.10 Sections for ARTEMIS</a>
<li><a href="#Test-Protocol">3.2.11 Explicit section markers with lazy plans</a>
<li><a href="#Test-Protocol">3.2.12 Developing with TAP</a>
<li><a href="#Test-Protocol">3.2.13 TAP tips</a>
</li></ul>
<li><a href="#Test-Protocol">3.3 Particular use-cases</a>
<ul>
<li><a href="#Test-Protocol">3.3.1 Report Groups</a>
<ul>
<li><a href="#Test-Protocol">3.3.1.1 Report grouping by same testrun</a>
<li><a href="#Test-Protocol">3.3.1.2 Report grouping by arbitrary idenitifier</a>
</li></ul>
</li></ul>
</li></ul>
<li><a name="toc_Test-Suite-Wrappers" href="#Test-Suite-Wrappers">4 Test Suite Wrappers</a>
<ul>
<li><a href="#Test-Suite-Wrappers">4.1 Available test suite wrappers</a>
<ul>
<li><a href="#Test-Suite-Wrappers">4.1.1 LMbench</a>
<li><a href="#Test-Suite-Wrappers">4.1.2 kernbench</a>
<li><a href="#Test-Suite-Wrappers">4.1.3 CTCS</a>
<li><a href="#Test-Suite-Wrappers">4.1.4 LTP</a>
<li><a href="#Test-Suite-Wrappers">4.1.5 dom0-meta</a>
</li></ul>
<li><a href="#Test-Suite-Wrappers">4.2 Environment variables</a>
</li></ul>
<li><a name="toc_Preconditions" href="#Preconditions">5 Preconditions</a>
<ul>
<li><a href="#Preconditions">5.1 SYNOPSIS</a>
<li><a href="#Preconditions">5.2 Precondition repository</a>
<ul>
<li><a href="#Preconditions">5.2.1 Normal preconditions</a>
<li><a href="#Preconditions">5.2.2 Macro preconditions</a>
<li><a href="#Preconditions">5.2.3 Precondition types</a>
<ul>
<li><a href="#Preconditions">5.2.3.1 Action preconditions</a>
<li><a href="#Preconditions">5.2.3.2 Highlevel preconditions</a>
</li></ul>
<li><a href="#Preconditions">5.2.4 Precondition description</a>
<ul>
<li><a href="#Preconditions">5.2.4.1 installer_stop</a>
<li><a href="#Preconditions">5.2.4.2 grub</a>
<li><a href="#Preconditions">5.2.4.3 package</a>
<li><a href="#Preconditions">5.2.4.4 copyfile</a>
<li><a href="#Preconditions">5.2.4.5 fstab</a>
<li><a href="#Preconditions">5.2.4.6 image</a>
<li><a href="#Preconditions">5.2.4.7 repository</a>
<li><a href="#Preconditions">5.2.4.8 type: prc</a>
<li><a href="#Preconditions">5.2.4.9 type: exec</a>
<li><a href="#Preconditions">5.2.4.10 quote subtleties</a>
<li><a href="#Preconditions">5.2.4.11 type: reboot</a>
<li><a href="#Preconditions">5.2.4.12 type: autoinstall</a>
<li><a href="#Preconditions">5.2.4.13 type: testprogram</a>
<li><a href="#Preconditions">5.2.4.14 type: virt</a>
<li><a href="#Preconditions">5.2.4.15 General precondition keys &ldquo;mountfile&rdquo;</a>
</li></ul>
</li></ul>
<li><a href="#Preconditions">5.3 Macro Preconditions</a>
<ul>
<li><a href="#Preconditions">5.3.1 A real live example: kernel boot test</a>
</li></ul>
<li><a href="#Preconditions">5.4 Producers</a>
<ul>
<li><a href="#Preconditions">5.4.1 Lazy precondition</a>
<li><a href="#Preconditions">5.4.2 Producer API</a>
</li></ul>
</li></ul>
<li><a name="toc_Commandline" href="#Commandline">6 Command line interface</a>
<ul>
<li><a href="#Commandline">6.1 SYNOPSIS</a>
<li><a href="#Commandline">6.2 Scheduling: hosts, queues, jobs</a>
<ul>
<li><a href="#Commandline">6.2.1 Create new queue, new host, bind both together</a>
<li><a href="#Commandline">6.2.2 Change queue priority</a>
</li></ul>
</li></ul>
<li><a name="toc_Web-User-Interface" href="#Web-User-Interface">7 Web User Interface</a>
<ul>
<li><a href="#Web-User-Interface">7.1 Usage</a>
<li><a href="#Web-User-Interface">7.2 Understanding Artemis Details</a>
<ul>
<li><a href="#Web-User-Interface">7.2.1 Part 1 Overview</a>
<li><a href="#Web-User-Interface">7.2.2 Part 2 Details</a>
<li><a href="#Web-User-Interface">7.2.3 Part 3 Testrun</a>
</li></ul>
</li></ul>
<li><a name="toc_Reports-API" href="#Reports-API">8 Reports::API</a>
<ul>
<li><a href="#Reports-API">8.1 Overview</a>
<li><a href="#Reports-API">8.2 Raw API Commands</a>
<ul>
<li><a href="#Reports-API">8.2.1 upload - attach a file to a report</a>
<ul>
<li><a href="#Reports-API">8.2.1.1 Synopsis</a>
<li><a href="#Reports-API">8.2.1.2 Parameters</a>
<li><a href="#Reports-API">8.2.1.3 Payload</a>
<li><a href="#Reports-API">8.2.1.4 Example usage</a>
</li></ul>
<li><a href="#Reports-API">8.2.2 mason - Render templates with embedded query language</a>
<ul>
<li><a href="#Reports-API">8.2.2.1 Synopsis</a>
<li><a href="#Reports-API">8.2.2.2 Parameters</a>
<li><a href="#Reports-API">8.2.2.3 Payload</a>
<li><a href="#Reports-API">8.2.2.4 Example usage</a>
</li></ul>
</li></ul>
<li><a href="#Reports-API">8.3 Query language DPath</a>
<ul>
<li><a href="#Reports-API">8.3.1 Reports Filter (SQL::Abstract)</a>
<ul>
<li><a href="#Reports-API">8.3.1.1 SQL::Abstract expressions</a>
<li><a href="#Reports-API">8.3.1.2 The data structure</a>
</li></ul>
<li><a href="#Reports-API">8.3.2 Data Filter (Data::DPath)</a>
<ul>
<li><a href="#Reports-API">8.3.2.1 Data::DPath expressions</a>
</li></ul>
<li><a href="#Reports-API">8.3.3 Optimizations</a>
</li></ul>
<li><a href="#Reports-API">8.4 Client Utility <code>artemis-api</code></a>
<ul>
<li><a href="#Reports-API">8.4.1 help</a>
<li><a href="#Reports-API">8.4.2 upload</a>
<li><a href="#Reports-API">8.4.3 mason</a>
</li></ul>
</li></ul>
<li><a name="toc_Complete-Use_002dCases" href="#Complete-Use_002dCases">9 Complete Use-Cases</a>
<ul>
<li><a href="#Complete-Use_002dCases">9.1 Automatic Xen testing</a>
<ul>
<li><a href="#Complete-Use_002dCases">9.1.1 Paths</a>
<li><a href="#Complete-Use_002dCases">9.1.2 Choose an image for Dom0 and images for each guest</a>
<li><a href="#Complete-Use_002dCases">9.1.3 PRC configuration</a>
<ul>
<li><a href="#Complete-Use_002dCases">9.1.3.1 Guest Start Configuration</a>
<li><a href="#Complete-Use_002dCases">9.1.3.2 Testsuite Configuration</a>
</li></ul>
<li><a href="#Complete-Use_002dCases">9.1.4 Preconditions</a>
<li><a href="#Complete-Use_002dCases">9.1.5 Resulting YAML config</a>
<li><a href="#Complete-Use_002dCases">9.1.6 Grub</a>
<li><a href="#Complete-Use_002dCases">9.1.7 Order Testrun</a>
</li></ul>
</li></ul>
<li><a name="toc_Artemis-Development" href="#Artemis-Development">10 Artemis Development</a>
<ul>
<li><a href="#Artemis-Development">10.1 Repositories</a>
<li><a href="#Artemis-Development">10.2 Starting/Stopping Artemis server applications</a>
<ul>
<li><a href="#Artemis-Development">10.2.1 Live environment</a>
<ul>
<li><a href="#Artemis-Development">10.2.1.1 Web User Interface</a>
<li><a href="#Artemis-Development">10.2.1.2 Reports::Receiver</a>
<li><a href="#Artemis-Development">10.2.1.3 Reports::API</a>
</li></ul>
<li><a href="#Artemis-Development">10.2.2 Development environment</a>
<ul>
<li><a href="#Artemis-Development">10.2.2.1 Preparing an MCP host</a>
<li><a href="#Artemis-Development">10.2.2.2 Web User Interface</a>
<li><a href="#Artemis-Development">10.2.2.3 Reports::Receiver</a>
<li><a href="#Artemis-Development">10.2.2.4 Reports::API</a>
</li></ul>
<li><a href="#Artemis-Development">10.2.3 Logfiles</a>
</li></ul>
<li><a href="#Artemis-Development">10.3 Deployment</a>
<ul>
<li><a href="#Artemis-Development">10.3.1 Create and upload Python packages</a>
<li><a href="#Artemis-Development">10.3.2 Create and upload Perl packages</a>
<li><a href="#Artemis-Development">10.3.3 Generate complete Artemis toolchain in opt-artemis package</a>
<li><a href="#Artemis-Development">10.3.4 Installation of the Web User Interface</a>
</li></ul>
<li><a href="#Artemis-Development">10.4 Upgrading a database schema</a>
<li><a href="#Artemis-Development">10.5 Environment variables</a>
<li><a href="#Artemis-Development">10.6 Files</a>
<ul>
<li><a href="#Artemis-Development">10.6.1 Special files</a>
<li><a href="#Artemis-Development">10.6.2 PID files</a>
<li><a href="#Artemis-Development">10.6.3 Log files</a>
</li></ul>
<li><a href="#Artemis-Development">10.7 Image preparation</a>
<li><a href="#Artemis-Development">10.8 temare - use a local temare</a>
<li><a href="#Artemis-Development">10.9 Host Forensics</a>
<ul>
<li><a href="#Artemis-Development">10.9.1 Investigate a host</a>
<li><a href="#Artemis-Development">10.9.2 Console</a>
<li><a href="#Artemis-Development">10.9.3 View Artemis spec</a>
<li><a href="#Artemis-Development">10.9.4 Restart the Artemis scripts on a waiting machine</a>
</li></ul>
<li><a href="#Artemis-Development">10.10 Troubleshooting</a>
<ul>
<li><a href="#Artemis-Development">10.10.1 Got a packet bigger than 'max_allowed_packet' bytes</a>
</li></ul>
</li></ul>
</li></ul>
</div>

<div class="node">
<p><hr>
<a name="Synopsis"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Technical-Infrastructure">Technical Infrastructure</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Synopsis</h2>

<p>ARTEMIS is an infrastructure.

<p>It consists of applications, tools and protocols for testing software
and evaluating the results. One focus is on testing Operating Systems
in virtualization environments on AMD hardware.

<p>There are 3 important layers:

     <ul>
<li><strong>Report Framework</strong>

     <li><strong>Test Suites</strong>

     <li><strong>Automation System</strong>

</ul>

<p>The layers work completely autonomously, though can also be connected
together.

<p>To fully exploit the system the tasks you need to learn are

     <ul>
<li><strong>Connect and prepare a new machine into the infrastructure</strong>

     <li><strong>Write tests using the Test Anything Protocol (TAP)</strong>

     <li><strong>Write preconditions to describe automation tasks</strong>

     <li><strong>Review results via Web interface</strong>

     <li><strong>Evaluate results via Report Query interface</strong>

</ul>

<p><strong>Person in charge</strong>: Steffen Schwigon

<div class="node">
<p><hr>
<a name="Technical-Infrastructure"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Test-Protocol">Test Protocol</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Synopsis">Synopsis</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Technical Infrastructure</h2>

<h3 class="section">2.1 Adding a new host into automation</h3>

<p>This chapter describes what you need to do in order to get a new
machine into the Artemis test rotation.

<h4 class="subsection">2.1.1 Make machine remote restartable</h4>

<p>In the osrc network this means attaching it to <code>osrc_rst</code> which
is the reset switch tool, a physical device plus the software to
trigger the reset.

<p><strong>Person in charge</strong>: Jan Krocker

<h4 class="subsection">2.1.2 Make machine PXE boot aware</h4>

     <ul>
<li>Set booting order in BIOS to network first

     <li>Create (or change) a file wotan:/tftpboot/cfgs/FOOBAR.lst

     <li>Insert the following as first host configuration, i.e. after serial and timeout settings

     <pre class="verbatim">     
     title Automatic test
     tftpserver 165.204.15.71
     configfile (nd)/tftpboot/FOOBAR.lst
</pre>

     <p>The IP address is that of our application server <code>bancroft</code>.

     <li>Set the appropriate DHCP config in wotan:/etc/dhcpd.conf

     <li>Search for your host in this file

     <li>Add this line inside the config block of your host:

     <pre class="verbatim">     
     option configfile "/tftpboot/cfgs/FOOBAR.lst";
</pre>

     <li>Force the dhcp server to reread its configuration with

     <pre class="verbatim">     
     kill -HUP $(pidof dhcpd)
</pre>

</ul>

<p><strong>Person in charge</strong>: Maik Hentsche

<h4 class="subsection">2.1.3 Add host to the hardware database</h4>

<p>If not already listed at <a href="http://bancroft.amd.com/hardwaredb/">http://bancroft.amd.com/hardwaredb/</a>
contact Jan Krocker.

<p><strong>Person in charge</strong>: Jan Krocker

<h4 class="subsection">2.1.4 Optionally: enable &lsquo;<samp><span class="samp">temare</span></samp>&rsquo; to generate tests for this host</h4>

<p>The steps until here are generally enough to put &lsquo;<samp><span class="samp">preconditions</span></samp>&rsquo;
for this host into the Artemis database and thus use the host for
tests.

<p>Anyway, you can additionally register the host in &lsquo;<samp><span class="samp">temare</span></samp>&rsquo;.

<p><em>temare</em> is the <dfn>Test Matrix Replacement</dfn> program that
schedules tests according to our test plan. If you want tests
scheduled for the new machine then follow these steps:

     <ul>
<li>Login as root on bancroft

     <li>Set the <code>PYTHONPATH</code> to include the <em>temare</em> src directory

     <pre class="verbatim">     
     export PYTHONPATH=$PYTHONPATH:/home/artemis/temare/src
</pre>

     <li>Add the host to temare hostlist

     <pre class="verbatim">     
     /home/artemis/temare/temare hostadd $hostname $memory $cores $bitness
</pre>

     <li>Add the host to <code>/home/artemis/temare/xentest.pl</code>

</ul>

<p><strong>Person in charge</strong>: Maik Hentsche, Frank Arnold

<p><a name="index-Index-entry-for-First-Chapter-1"></a>

<div class="node">
<p><hr>
<a name="Test-Protocol"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Test-Suite-Wrappers">Test Suite Wrappers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Technical-Infrastructure">Technical Infrastructure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Test Protocol</h2>

<h3 class="section">3.1 Test Anything Protocol (TAP)</h3>

<h3 class="section">3.2 Tutorial</h3>

<h4 class="subsection">3.2.1 Just plan and success</h4>

<p>Example:

<pre class="verbatim">
 1..3
 ok
 ok
 not ok
</pre>

<h4 class="subsection">3.2.2 Succession numbers</h4>

<p>Example:

<pre class="verbatim">
1..3
ok 1
ok 2
not ok 3
</pre>

     <ul>
<li>Missing lines can be detected. 
</ul>

<h4 class="subsection">3.2.3 Test descriptions</h4>

<p>Example:

<pre class="verbatim">
1..3
ok 1 - input file opened
ok 2 - file content
not ok 3 - last line
</pre>

     <ul>
<li>Readability. 
</ul>

<h4 class="subsection">3.2.4 Mark tests as TODO</h4>

<p>Example:

<pre class="verbatim">
1..3
ok 1 - input file opened
ok 2 - file content
not ok 3 - last line # TODO
</pre>

     <ul>
<li>mark not yet working tests as "TODO"
<li>allows test-first development
<li>"ok" TODOs can be recognized
 ("unexpectedly succeeded")
</ul>

<h4 class="subsection">3.2.5 Comment TODO tests with reason</h4>

<p>Example:

<pre class="verbatim">
1..3
ok 1 - input file opened
ok 2 - file content
not ok 3 - last line # TODO just specced
</pre>

     <ul>
<li>comment the TODO reason
</ul>

<h4 class="subsection">3.2.6 Mark tests as SKIP (with reason)</h4>

<p>Example:

<pre class="verbatim">
1..3
ok 1 - input file opened
ok 2 - file content
ok 3 - last line # SKIP missing prerequisites
</pre>

     <ul>
<li>mark tests when not really run (note the \u201cok\u201d)
<li>keeps succession numbers in sync
</ul>

<h4 class="subsection">3.2.7 Diagnostics</h4>

<p>Example:

<pre class="verbatim">
1..3
ok 1 - input file opened
ok 2 - file content
not ok 3 - last line # TODO just specced
# Failed test 'last line'
# at t/data_dpath.t line 410.
# got: 'foo'
# expected: 'bar'
</pre>

     <ul>
<li>Details
</ul>

<h4 class="subsection">3.2.8 YAML Diagnostics</h4>

<p>Example:

<pre class="verbatim">
1..3
ok 1 - input file opened
ok 2 - file content
not ok 3 - last line # TODO just specced
  ---
  message: Failed test 'last line' at t/data_dpath.t line 410.
  severity: fail
  data:
    got: 'foo'
    expect: 'bar'
  ...
</pre>

     <ul>
<li>allows parsable diagnostics
<li>we use that to track values inside TAP
<li>have a leading test line with number+description
<li>track complete data structures according to it
          <ul>
<li>e.g., benchmark results
</ul>
     </ul>

<h4 class="subsection">3.2.9 Headers for ARTEMIS</h4>

<p>Example:

<pre class="verbatim">
1..3
# Artemis-Suite-Name: Foo-Bar
# Artemis-Suite-Version: 2.010013
ok 1 - input file opened
ok 2 - file content
not ok 3 - last line # TODO just specced
@end example

@itemize
@item we use diagnostics lines (``hot comments'')
@item semantics only to our TAP applications
@end itemize

These are the headers that apply to the whole report:

@verbatim
 # Artemis-suite-name:                 -- suite name
 # Artemis-suite-version:              -- suite version
 # Artemis-machine-name:               -- machine/host name
 # Artemis-machine-description:        -- more details to machine
 # Artemis-starttime-test-program:     -- start time for complete test
                                          (including guests)
 # Artemis-endtime-test-program:       -- end time for complete test
                                          (including guests)
 # Artemis-reportgroup-testrun:        -- associate this report with other 
                                          reports of same testrun_id
 # Artemis-reportgroup-arbitrary:      -- associate this report with other 
                                          reports of same arbitrary id
                                          (can be any string, but should be
                                          unique between all groups of the db,
                                          eg., an md5-hash of common 
                                          characteristics of all test of one 
                                          group)

</pre>

<h4 class="subsection">3.2.10 Sections for ARTEMIS</h4>

<p>Example:

<pre class="verbatim">
1..2
# Artemis-section: arithmetics
ok 1 add
ok 2 multiply
1..1
# Artemis-section: string handling
ok 1 concat
1..3
# Artemis-section: benchmarks
ok 1
ok 2
ok 3
</pre>

     <ul>
<li>we recognize &ldquo;sections&rdquo;, each with its own plan
<li>allows structuring of results,
<li>better readability later in web interface
</ul>

<p>These are the headers that apply to single sections:

<pre class="verbatim">

 # Artemis-explicit-section-start:   -- explicitely start a section now
                                        instead of autorecognition
 # Artemis-ram:                      -- memory
 # Artemis-cpuinfo:                  -- what CPU
 # Artemis-uname:                    -- kernel information
 # Artemis-osname:                   -- OS information
 # Artemis-bios:                     -- BIOS information
 # Artemis-flags:                    -- flags, usually linux kernel
 # Artemis-changeset:                -- exact changeset of the currently tested software or kernel
 # Artemis-description:              -- more description of the currently tested software or kernel, 
                                        e.g., if changeset is not enough
 # Artemis-uptime:                   -- uptime, maybe the test run time
 # Artemis-language-description:     -- for Software tests, 
                                        like "Perl 5.10", "Python 2.5"
 # Artemis-xen-version:              -- Xen version
 # Artemis-xen-changeset:            -- particular Xen changeset
 # Artemis-xen-dom0-kernel:          -- the kernel version of the dom0
 # Artemis-xen-base-os-description:  -- more verbose OS information
 # Artemis-xen-guest-description:    -- description of a guest
 # Artemis-xen-guest-test:           -- the started test program
 # Artemis-xen-guest-start:          -- start time of test
 # Artemis-xen-guest-flags:          -- flags used for starting the guest
 # Artemis-kvm-module-version:       -- version of KVM kernel module
 # Artemis-kvm-userspace-version:    -- version of KVM userland tools
 # Artemis-kvm-kernel:               -- version of kernel
 # Artemis-kvm-base-os-description:  -- more verbose OS information
 # Artemis-kvm-guest-description:    -- description of a guest
 # Artemis-kvm-guest-test:           -- the started test program
 # Artemis-kvm-guest-start:          -- start time of test
 # Artemis-kvm-guest-flags:          -- flags used for starting the guest
 # Artemis-flags:                    -- Flags that were used to boot the OS
 # Artemis-reportcomment:            -- Freestyle comment

</pre>

<h4 class="subsection">3.2.11 Explicit section markers with lazy plans</h4>

<p>In TAP it is allowed to print the plan (1..n) after the test lines (a
&ldquo;lazy plan&rdquo;).  In our ARTEMIS environment with concatenated sections
this would break the default section splitting which uses the plan to
recognize a section start.

<p>If you want to use such a &ldquo;lazy plan&rdquo; in your report you can print
an ARTEMIS header <code>Artemis-explicit-section-start</code> to explictely
start a section. Everything until the next header
<code>Artemis-explicit-section-start</code> is building one section. This
also means that if you used this header <strong>once</strong> in a report you
need to use it for <strong>all</strong> sections in this report.

<p>The <code>Artemis-explicit-section-start</code> typically ignores its value
but it is designed anyway to allow any garbage after the value that
can help you visually structure your reports because explicit sections
with &ldquo;lazy plans&rdquo; make a report hard to read.

<p>Example:

<pre class="verbatim">
# Artemis-explicit-section-start: 1 ------ arithmetics -------
# Artemis-section: arithmetics
ok 1 add
ok 2 multiply
1..2
# Artemis-explicit-section-start: 1 ------ string handling -------
# Artemis-section: string handling
ok 1 concat
1..1
# Artemis-explicit-section-start: 1 ------ benchmarks -------
# Artemis-section: benchmarks
ok 1
ok 2
ok 3
1..3
</pre>

<h4 class="subsection">3.2.12 Developing with TAP</h4>

     <ul>
<li>TAP::Parser
          <ul>
<li><code>prove</code> tool
<li>overall success and statistics
<li>allows &lsquo;<samp><span class="samp">formatters</span></samp>&rsquo;
<li>used to produce web reports
</ul>
     </ul>

<pre class="verbatim">
$ prove t/*.t
t/00-load.........ok
t/boilerplate.....ok
t/pod-coverage....ok
All tests successful.
Files=4, Tests=6, 0 wallclock secs
( 0.05 usr 0.00 sys + 0.28 cusr 0.05 csys = 0.38 CPU)
Result: PASS
</pre>

<h4 class="subsection">3.2.13 TAP tips</h4>

     <ul>
<li>Easy to produce but using it <strong>usefully</strong> can be a challenge
<li>think &ldquo;ARTEMIS&rdquo; &ndash; l'Art `emis &ndash; &ldquo;The art to emit&rdquo;
<li>use invariable test descriptions
<li>put meta information in diagnostics lines, not test descriptions
<li>use the description after <code># TODO/SKIP</code>
<li>cheat visible (or: don't cheat invisible)
<li>really use <code># TODO/SKIP</code>
<li>This keeps TAP evaluation consistent
</ul>

<h3 class="section">3.3 Particular use-cases</h3>

<h4 class="subsection">3.3.1 Report Groups</h4>

<h5 class="subsubsection">3.3.1.1 Report grouping by same testrun</h5>

<p>If we have a Xen environment then there are many guests each running
some test suites but they don't know of each other.

<p>The only thing that combines them is a common testrun-id. If each
suite just reports this testrun-id as the group id, then the receiving
side can combine all those autonomously reporting suites back together
by that id.

<p>So simply each suite should output

<pre class="verbatim">
# Artemis-reportgroup-testrun: 1234
</pre>

<p>with 1234 being a testrun ID that is available via the environment
variable <code>$ARTEMIS_TESTRUN</code>. This variable is provided by the
automation layer.

<h5 class="subsubsection">3.3.1.2 Report grouping by arbitrary idenitifier</h5>

<p>If the grouping id is not a testrun id, e.g., because you have set up
a Xen environment without the ARTEMIS automation layer, then generate
one random value once in dom0 by yourself and use that same value
inside all guests with the following header:

     <ul>
<li>get the value:

     <pre class="verbatim">     
     ARTEMIS_REPORT_GROUP=`date|md5sum|awk '{print $1}'`
</pre>

     <li>use the value:

     <pre class="verbatim">     
     # Artemis-reportgroup-arbitrary: $ARTEMIS_REPORT_GROUP
</pre>

</ul>

<p>How that value gets from <em>dom0</em> into the guests is left as an
exercise, e.g. via preparing the init scripts in the guest images
before starting them. That's not the problem of the test suite
wrappers, they should only evaluate the environment variable
<code>ARTEMIS_REPORT_GROUP</code>.

<p><strong>Person in charge</strong>: Frank Becker

<div class="node">
<p><hr>
<a name="Test-Suite-Wrappers"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Preconditions">Preconditions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Test-Protocol">Test Protocol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Test Suite Wrappers</h2>

<p>This section is about the test suites and wrappers around existing
suites. These wrappers are part of our overall test infrastructure.

<p>It's basically about the middle part in the following picture:

<p>[[image:artemis_architecture_overview.png | 800px]]

<p>We have wrappers for existing test and benchmark suites.

<p>Wrappers just run the suites as a user would manually run them but
additionally extract results and produce TAP (Test Anything Protocol).

<p>We have some specialized, small test suites that complement the
general suites, e.g. for extracting meta information or parsing logs
for common problems.

<p>If the environment variables

<pre class="verbatim">
ARTEMIS_REPORT_SERVER
ARTEMIS_REPORT_PORT
</pre>

<p>are set the wrappers report their results by piping their TAP output
there, else they print to STDOUT.

<h3 class="section">4.1 Available test suite wrappers</h3>

<h4 class="subsection">4.1.1 LMbench</h4>

     <dl>
<dt><b>artemis_testsuite_lmbench.sh</b><dd>
A wrapper around the benchmark suite <em>LMbench</em>.

     <p>See also <a href="http://www.bitmover.com/lmbench/">http://www.bitmover.com/lmbench/</a>.

</dl>

<h4 class="subsection">4.1.2 kernbench</h4>

     <dl>
<dt><b>artemis_testsuite_kernbench.sh</b><dd>
A wrapper around the benchmark suite <em>kernbench</em>.

     <p>See also <a href="http://freshmeat.net/projects/kernbench/">http://freshmeat.net/projects/kernbench/</a>.

</dl>

<h4 class="subsection">4.1.3 CTCS</h4>

     <dl>
<dt><b>artemis_testsuite_ctcs.sh</b><dd>
A wrapper around the <em>Cerberus Test Control System (CTCS)</em>.

     <p>See also <a href="http://sourceforge.net/projects/va-ctcs/">http://sourceforge.net/projects/va-ctcs/</a>.

</dl>

<h4 class="subsection">4.1.4 LTP</h4>

     <dl>
<dt><b>artemis_testsuite_ltp.sh</b><dd>
A wrapper around the <em>Linux Test Project (LTP)</em>.

     <p>See also <a href="http://ltp.sourceforge.net/">http://ltp.sourceforge.net/</a>.

</dl>

<h4 class="subsection">4.1.5 dom0-meta</h4>

     <dl>
<dt><b>artemis_testsuite_dom0_meta.sh</b><dd>
A suite that produces meta information about the <em>dom0</em>
environment.

</dl>

<h3 class="section">4.2 Environment variables</h3>

<p>The ARTEMIS automation layer provides some environment variables that
the wrappers can use:

     <dl>
<dt><b>ARTEMIS_TESTRUN</b><dd>Currently active Testrun ID.

     <br><dt><b>ARTEMIS_SERVER</b><dd>The controlling automation Server that initiated this testrun.

     <br><dt><b>ARTEMIS_REPORT_SERVER</b><dd>The target server to which the tests should report their results in
TAP.

     <br><dt><b>ARTEMIS_REPORT_PORT</b><dd>The target port to which the tests should report their results in
TAP. Complements <code>ARTEMIS_REPORT_SERVER</code>.

     <br><dt><b>ARTEMIS_REPORT_API_PORT</b><dd>The port on which the more sophisticated Remote Reports API is
available. It's running on the same host as
<code>ARTEMIS_REPORT_SERVER</code>.

     <br><dt><b>ARTEMIS_TS_RUNTIME</b><dd>Maximum runtime after which the testprogram will not be restarted when
it runs in a loop. (This is a more passive variant than a timeout.)

     <br><dt><b>ARTEMIS_GUEST_NUMBER</b><dd>Virtualisation guests are ordered, this is the guest number or 0 if
not a guest.

     <br><dt><b>ARTEMIS_NTP_SERVER</b><dd>The server where to request NTP dates from.

</dl>

<p>These variables should be used in the TAP of the suite as
<em>Artemis</em> headers. Important use-case is "report groups", see next
chapter.

<p><strong>Person in charge</strong>: Frank Becker

<div class="node">
<p><hr>
<a name="Preconditions"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Commandline">Commandline</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Test-Suite-Wrappers">Test Suite Wrappers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Preconditions</h2>

<p>The central thing that is needed before a test is run is a so called
<dfn>precondition</dfn>. Creating those preconditions is the main task
needed to do when using the automation framework.

<p>Most of the <em>preconditions</em> describe packages that need to be
installed. Other preconditions describe how subdirs should be copied
or scripts be executed.

<p>A <em>precondition</em> can depend on other preconditions, leading to a
tree of preconditions that will be installed from the leaves to the
top.

<h3 class="section">5.1 SYNOPSIS</h3>

     <ul>
<li>Create a (maybe temporary) file

     <li>Define conditions for a testrun: the <dfn>preconditions</dfn>

     <li>Put the precondition into the database, maybe referring to other preconditions

     <li>Create a testrun in the database, referring to the precondition

     <li>Wait until the tesrun is executed and results are reported

</ul>

<h3 class="section">5.2 Precondition repository</h3>

<h4 class="subsection">5.2.1 Normal preconditions</h4>

<p>We store preconditions in the database and assign <em>testruns</em> to
them (also in the database).

<p>Usually the preconditions were developed in a (temporary) file and
then entered into the database with a tool. After that the temporary
file can be deleted. Note that such a precondition file can contain
multiple precondition as long as they are formated as valid YAML.

<p><em>Preconditions</em> can be kept in files to re-use them when creating
testruns but that's not needed for archiving purposes, only for
creation purposes.

<h4 class="subsection">5.2.2 Macro preconditions</h4>

<p>Though, there is another mechanism on top of normal preconditions:
<dfn>Macro Preconditions</dfn>. These allow to bundle several preconditions
into a common use-case and mark placeholders in them, see See <a href="#Macro-Preconditions">Macro Preconditions</a>.

<p>These <em>macro preconditions</em> should be archived, as they are only
template files which are rendered into final preconditions. Only the
final preconditions are stored in the database.

<p>Macro preconditions can be stored in

<pre class="verbatim">
/data/bancroft/artemis/live/repository/macropreconditions/
</pre>

<h4 class="subsection">5.2.3 Precondition types</h4>

<p>Some preconditions types can contain other more simple precondition
types. To distinguish them we call them <em>Highlevel preconditions</em>
and <em>Action preconditions</em>, accordingly.

<h5 class="subsubsection">5.2.3.1 Action preconditions</h5>

<p>The following <dfn>action</dfn> precondition types are allowed:

     <dl>
<dt><b>package</b><dd>
A package (kernel, library, etc.), of type <em>.tar</em>, <em>.tar.gz</em> or <em>.tar.bz2</em>

     <br><dt><b>image</b><dd>
A complete OS image of type <em>.iso</em>, <em>.tar.gz</em>, <em>.tgz</em>,
<em>.tar</em>, <em>.tar.bz2</em>

     <br><dt><b>prc</b><dd>
Create a config for the <dfn>PRC</dfn> module of the automation layer.

     <br><dt><b>copyfile</b><dd>
One file that can just be copied/rsync'd

     <br><dt><b>installer_stop</b><dd>
Don't reboot machine after system installer finished

     <br><dt><b>grub</b><dd>
Overwrite automatically generated grub config with one provided by the tester

     <br><dt><b>fstab</b><dd>
Append a line to /etc/fstab

     <br><dt><b>repository</b><dd>
Fetch data from a git, hg or svn repository

     <br><dt><b>exec</b><dd>
Execute a script during installation phase

     <br><dt><b>reboot</b><dd>
Requests a reboot test and states how often to reboot.

</dl>

<h5 class="subsubsection">5.2.3.2 Highlevel preconditions</h5>

<p>Currently only the following <dfn>high level</dfn> precondition type is
allowed:

     <dl>
<dt><b>virt</b><dd>
Generic description for Xen or KVM

</dl>

<p><em>High level preconditions</em> both define stuff and can also contain
other preconditions.

<p>They are handled with some effort to <em>Do The Right Thing</em>, i.e.,
a defined root image in the high level precondition is always
installed first. All other preconditions are installed in the order
defined by its tree structure (depth-first).

<h4 class="subsection">5.2.4 Precondition description</h4>

<p>We describe preconditions in YAML files (<a href="http://www.yaml.org/">http://www.yaml.org/</a>).

<p>All preconditions have at least a key

<pre class="verbatim">
precondition_type: TYPE
</pre>

<p>and optionally

<pre class="verbatim">
name: VERBOSE DESCRIPTION
shortname: SHORT DESCRIPTION
</pre>

<p>then the remaining keys depend on the TYPE.

<h5 class="subsubsection">5.2.4.1 installer_stop</h5>

     <ul>
<li>stop run after system installer

     <pre class="verbatim">     
     ---
     precondition_type: installer_stop
</pre>

<h5 class="subsubsection">5.2.4.2 grub</h5>

     <li>overwrite automatically generated grub config

          <ul>
<li>Note: multiple lines in the grub file have to be given as one line separated by C&lt;\n&gt; in YAML

          <li>the variables $grubroot and $root are substituted with grub and /dev/* notation of the root partition respectively

          <li>$root substitution uses the notation of the installer kernel. This may cause issues when the installer detects /dev/sd? and the kernel under test detects /dev/hd? or vice versa

          <li>since grub always expects parentheses around the device, they are part of the substitution string for $grubroot

          <li>note the syntax, to get multiline strings in YAML you need to start them with | and a newline

          <pre class="verbatim">          
          ---
          precondition_type: grub
          config: |
            title Linux
              root $grubroot
              kernel /boot/vmlinuz root=$root"
     </pre>

     </ul>

</ul>

<h5 class="subsubsection">5.2.4.3 package</h5>

     <ul>
<li>path names can be absolut or relative to
 /data/bancroft/artemis/development/repository/packages/

     <li>supported packages types are rpm, deb, tar, tar.gz and tar.bz2

     <li>package type is detected automatically

     <li>absolute path: usually /data/bancroft/...

     <li>relative path: relative to /data/bancroft/artemis/(live|development)/

     <pre class="verbatim">     
     ---
     filename: /data/bancroft/artemis/live/repository/packages/linux/linux-2.6.27.7.tar.bz2
     precondition_type: package
</pre>

</ul>

<h5 class="subsubsection">5.2.4.4 copyfile</h5>

     <ul>
<li>a file that just needs to be scp or copied:

          <ul>
<li>supported protocols are &ldquo;scp&rdquo;, &ldquo;nfs&rdquo; and &ldquo;local&rdquo;

          <li>the part before the first colon in the unique name is used as server name

          <li>the server name part is ignored for local

          <li>if dest ends in a slash, the file is copied with its basename preserved into the denoted directory

          <li>whether the &ldquo;dest&rdquo; is interpreted as a directory or a file is decided by the underlying &ldquo;scp&rdquo; or &ldquo;cp&rdquo; semantics, i.e., it depends on whether a directory already exists.

          <pre class="verbatim">          
          ---
          precondition_type: copyfile
          protocol: nfs
          source: osko:/export/image_files/official_testing/README
          dest: /usr/local/share/artemis/perl510
     </pre>

     </ul>

</ul>

<h5 class="subsubsection">5.2.4.5 fstab</h5>

     <ul>
<li>a line to add to /etc/fstab, e.g., to enable mounts once the system boots

     <pre class="verbatim">     
     ---
     precondition_type: fstab
     line: "165.204.85.14:/vol/osrc_vol0 /home nfs auto,defaults 0 0" 
</pre>

</ul>

<h5 class="subsubsection">5.2.4.6 image</h5>

<p>usually the root image that is unpacked to a partition
(this is in contrast to a guest file that's just there)

     <ul>
<li>partition and mount are required, all other options are optional

     <li>mount points are interpreted as seen inside the future installed system

     <li>if no image is given, the already installed one is reused, i.e., only the mountpoint is mounted; make sure this is possible or your test will fail!

     <li>can be either an iso file which is copied with dd or a tar, tar.gz or
 tar.bz2 package which is unpacked into the partition

     <li>partitions are formated ext3 (only when image is given)
and mounted to mount afterwards

          <ul>
<li>this is why image exists at all, copyfile does not provide this

          <li>absolute &ldquo;image&rdquo;: absolute

          <li>relative &ldquo;image&rdquo;: relative to /data/bancroft/artemis/{live|development}/repository/images
If not given, then it re-uses the partition without formatting/unpacking it.

          <li>partition: Can be /dev/xxx or LABEL or UUID.

          <pre class="verbatim">          
          ---
          precondition_type: image
          mount: /
          partition: testing
          image: /data/bancroft/artemis/{live|development}/repository/images/rhel-5.2-rc2-32bit.{iso,.tar.gz,.tgz,.tar,.tar.bz2} (OPTIONAL)
     </pre>

     </ul>

</ul>

<h5 class="subsubsection">5.2.4.7 repository</h5>

     <ul>
<li>git and hg are supported

     <li>type and url are mandatory, target and revision are optional

     <li>target denotes the directory where the source is placed in, the leading slash can be left out (i.e. paths can be given relative to root directory &rdquo;'/&rdquo;')

     <pre class="verbatim">     
     ---
     precondition_type: repository
     type: git
     url: git://git.kernel.org/pub/scm/linux/kernel/git/avi/kvm.git
     target: kvm
     revision: c192a1e274b71daea4e6dd327d8a33e8539ed937
</pre>

</ul>

<h5 class="subsubsection">5.2.4.8 type: prc</h5>

<p>Is typically contained implicitely with the abstract precondition
<em>virt</em>. But can also be defined explicitely, e.g., for kernel
tests.

<p>Creates config for PRC. This config controls what is to be run and
started when the machine boots.

     <ul>
<li>guest number

     <p>If it is a guest, for host system use 0.

     <li>test_program

     <p>startet after boot by the PRC

     <li>runtime

     <p>The wanted time, how long it runs, in seconds, this value will be used
to set an environment variable <code>ARTEMIS_TS_RUNTIME</code>, which is
used by the test suite wrappers.

     <li>timeout_testprogram

     <p>Time that the testprogram is given to run, at most, after that it is
killed (SIGINT, SIGKILL).

     <li>guests

     <p>Only used for virtualization tests. Contains an array, one entry per
guest which defines how a guest is started. Can be a SVM file for Xen
or an executable for KVM.

     <pre class="verbatim">     
     precondition_type: prc
     config:
          runtime: 30
          test_program: /bin/uname_tap.sh
          timeout_after_testprogram: 90
          guests:
           - svm:  /xen/images/..../foo.svm
           - svm:  /xen/images/..../bar.svm
           - exec: /xen/images/..../start_a_kvm_guest.sh
</pre>

<h5 class="subsubsection">5.2.4.9 type: exec</h5>

     <p>Defines which program to run at the installation phase.

     <pre class="verbatim">     
     precondition_type: exec
     filename: /bin/some_script.sh
     options: 
       - -v
       - --foo
       - --bar="hot stuff"
</pre>

     <p>The quotes in this example are actually wrong but left in so you learn
the following lesson:

<h5 class="subsubsection">5.2.4.10 quote subtleties</h5>

     <p>Please note some subtlety about quotes.

          <ul>
<li>This is YAML. And YAML provides its own way of quoting.

          <p>So this

          <pre class="verbatim">          
          precondition_type: exec
          filename: /bin/some_script.sh
          options: 
            - --foo
     </pre>

          <p>and this

          <pre class="verbatim">          
          precondition_type: exec
          filename: /bin/some_script.sh
          options: 
            - "--foo"
     </pre>

          <p>are actually the same (the value is always: <code>--foo</code>) because
quotes at the beginning and end of a YAML line are used by YAML. When
you use quotes at other places like in

          <pre class="verbatim">          
          precondition_type: exec
          filename: /bin/some_script.sh
          options: 
            - --bar="hot stuff"
     </pre>

          <p>then they are not part of the YAML line but part of the value, so this
time the value is: <code>--bar="hot stuff"</code>.

          <li>Quotes are not shell quotes.

          <p>So if you used quotes and they are not YAML quotes but part of the
value then you should know that they are <strong>not</strong> evaluated by a
shell when <code>some_script.sh</code> is called, because we use
<code>system()</code> without a shell layer to start it.

          <p>That's why in above example the quoted value <code>"hot stuff"</code> (with
quotes!) is given as parameter <code>--bar</code> to the program. This
usually <strong>not</strong> what you want.

          <li>Summary: Yo nearly never need quotes.

          <p>This is good enough:

          <pre class="verbatim">          
          precondition_type: exec
          filename: /bin/some_script.sh
          options: 
            - -v
            - --foo
            - --bar=hot stuff
     </pre>

     </ul>

<h5 class="subsubsection">5.2.4.11 type: reboot</h5>

     <p>Requests a reboot test and states how often to reboot.

     <p><strong>Note:</strong> Reboot count of 1 actually means boot two times since
the first boot is always counted as number 0.

     <pre class="verbatim">     
     precondition_type: reboot
     count: 2
</pre>

<h5 class="subsubsection">5.2.4.12 type: autoinstall</h5>

     <p>Install a system using autoinstall scripts. The filename denotes the
grub config to be used. It is mandatory and can be given as absolut
path or relative to /data/bancroft/.../repository/install_grub/. The
optional timeout is measured in second. If its absent a default value
is used.

     <pre class="verbatim">     
     precondition_type: autoinstall
     filename: suse/SLES10SP3_x86_64.lst
     timeout: 1800
</pre>

<h5 class="subsubsection">5.2.4.13 type: testprogram</h5>

     <p>Define which test program to run. This way of defining a test program
should be prefered to using the <strong>PRC</strong> type precondition. Only the
<strong>testprogram</strong> precondition guarantees parsing that sets all
internal Artemis variables correctly.

     <pre class="verbatim">     
     precondition_type: testprogram
     runtime: 30
     program: /bin/uname_tap.sh
     timeout: 90
     parameters:
     - --verbose
</pre>

<h5 class="subsubsection">5.2.4.14 type: virt</h5>

     <p>A virtualization environment.

          <ul>
<li>guest root always needs to name the file to mount since its not easy or even impossible to get this name for some ways to install
the root image (like tar.gz packages or subdir)

          <li>guest root and guest config are installed inside the host, guest preconditions are installed inside the guest image

          <li>guests can be started with xm create $xenconf, evaluation of $kvmconf or executing the $execconf script, thus only one of these three must be provided

     </ul>

     <li>&rdquo;'Note&rdquo;': virt instead of virtualisation is used to reduce confusion for users whether British English (virtualisation) or American English (virtualization) is expected

     <li>key &ldquo;arch&rdquo;
 arch: linux64 | linux32             (needed for for artemis toolchain)

     <pre class="verbatim">     
     name: automatically generated Xen test
     precondition_type: virt
     host:
       preconditions:
       - filename: /data/bancroft/artemis/live/repository/packages/xen/builds/x86_64/xen-3.3-testing/xen-3.3-testing.2009-03-20.18614_f54cf790ffc7.x86_64.tgz
         precondition_type: package
       - filename: /data/bancroft/artemis/live/repository/packages/artemisutils/sles10/xen_installer_suse.tar.gz
         precondition_type: package
       - filename: /bin/xen_installer_suse.pl
         precondition_type: exec
       root:
         precondition_type: image
         partition: testing
         image: /data/bancroft/artemis/live/repository/images/suse/suse_sles10_64b_smp_raw.tar.gz
         mount: /
         arch: linux64
       testprogram:
         execname: /opt/artemis/bin/artemis_testsuite_dom0_meta.sh
         timeout_testprogram: 10800
     guests:
     - config:
         precondition_type: copyfile
         protocol: nfs
         name: bancroft:/data/bancroft/artemis/live/repository/configs/xen/001-sandschaki-1237993266.svm
         dest: /xen/images/
         svm: /xen/images/001-sandschaki-1237993266.svm
       root:
         precondition_type: copyfile
         protocol: nfs
         arch: linux64
         name: osko:/export/image_files/official_testing/redhat_rhel4u7_64b_up_qcow.img
         dest: /xen/images/
         mountfile: /xen/images/001-sandschaki-1237993266.img
         mounttype: raw
       testprogram:
         execname: /opt/artemis/bin/py_ltp
         timeout_after_testprogram: 10800
</pre>

</ul>

<h5 class="subsubsection">5.2.4.15 General precondition keys &ldquo;mountfile&rdquo;</h5>

<p>These 2 options are possible in each precondition. With that you can
execute the precondition inside guest images:

<pre class="verbatim">
mountfile: ...
mountpartition: ...
mounttype: @TODO{is this the same as mountfile, mountpartition?}
</pre>

<p>- 1. only mountfile: eg. rawimage, file loop-mounted
- 2. only mountpartition: then mount that partition
- 3. image file with partitions: mount the imagefile and from that only the given partition

<p><strong>Person in charge</strong>: Maik Hentsche

<p><a name="Macro-Preconditions"></a>

<h3 class="section">5.3 Macro Preconditions</h3>

<p>This section describes macro precondition files as they are stored in
<code>/data/bancroft/artemis/live/repository/macropreconditions/</code>.

<p>A macro precondition denotes a file containing one or multiple
preconditions and additional TemplateToolkit code.

<p>In most cases preconditions for similar tests will only differ in one
or very few keys. Thus precondition files could easily be reused by
only changing these few keys. This is made easier with using macro
preconditions. The macro precondition file should contain all
preconditions to be reused. All variable keys should be substituted by
appropriate TemplateToolkit variables. When creating the new testrun
actual values for these TemplateToolkit variables have to provided.

<p>Macro preconditions are <strong>not</strong> stored in the database. They are
only a tool to ease the creation of preconditions. Only the
<strong>resulting</strong> preconditions are stored in database.

<p>To make parsing macro preconditions easier required and optional
fields can be named after a comment field in the first lines of the
file after the keys <code>artemis-mandatory-fields</code> and
<code>artemis-optional-fields</code> respectively as in the following example:

<pre class="verbatim">
# artemis-mandatory-fields: id
# artemis-optional-fields: kernel
</pre>

<p>None of these <code># artemis-*</code> headers are required. But they help
on frontend (like the Web GUI), therefor if they are missing then some
functionality in frontends may also be missing.

<p>The values for the placeholders can be filled via

<pre class="verbatim">
artemis-testrun new [all usual options] \
    --macroprecond=FILENAME \
     -DPLACEHOLDER1=VALUE1 \
     -DPLACEHOLDER2=VALUE2 \
     -DPLACEHOLDER3=VALUE3
</pre>

<p>The FILENAME is a complete filename with absolute path.

<p>There is no restriction on TemplateToolkit code for variable
substitution. The following example could be used to generate a
default value for the precondition key id.

<pre class="verbatim">
[% id = BLOCK %][% IF id %][% id %][%ELSE%]2009-06-29-perfmon[% END %][% END %]
</pre>

<h4 class="subsection">5.3.1 A real live example: kernel boot test</h4>

     <ul>
<li>Macroprecondition

     <pre class="verbatim">     
     # artemis-mandatory-fields: kernel_version
     # artemis-optional-fields: kernelpkg
     ---
     arch: linux64
     image: suse/suse_sles10_64b_smp_raw.tar.gz
     mount: /
     partition: testing
     precondition_type: image
     ---
     precondition_type: copyfile
     name: /data/bancroft/artemis/live/repository/testprograms/uname_tap/uname_tap.sh
     dest: /bin/
     protocol: local
     ---
     precondition_type: copyfile
     name: /data/bancroft/artemis/live/repository/packages/artemisutils/kernel/gen_initrd.sh
     dest: /bin/
     protocol: local
     ---
     [% kernelpkg = BLOCK %][% IF kernelpkg %][% kernelpkg %][%ELSE%]kernel/linux-[% kernel_version %].tar.gz[% END %][% END %]
     precondition_type: package
     filename: [% kernelpkg %]
     ---
     precondition_type: exec
     filename: /bin/gen_initrd.sh
     options:
       - [% kernel_version %]
     ---
     precondition_type: prc
     config:
           runtime: 30
           test_program: /bin/uname_tap.sh
           timeout_testprogram: 90
</pre>

     <li>The test script

     <p>The test script <code>uname_tap.sh</code> to which the macro precondition
refers is just a shell script that examines uname output:

     <pre class="verbatim">     
     #! /bin/sh
     echo "1..2"
     echo "# Artemis-Suite-Name: Kernel-Boot"
     echo "# Artemis-Suite-Version: 1.00"
     echo "# Artemis-Machine-Name: " `hostname`
     
     if [ x`uname` != xLinux ] ; then echo -n "not " ; fi
     echo "ok - We run on Linux"
     
     if uname -a | grep -vq x86_64 ; then echo -n "not " ; fi
     echo "ok - Looks like x86_64"
</pre>

     <li>Command line

     <p>Once you wrote the macro precondition and the test script all you need
is this command line:

     <pre class="verbatim">     
     artemis-testrun new \
       --hostname=dickstone \
       --macroprecond=/data/bancroft/artemis/live/repository/macropreconditions/kernel/kernel_boot.mpc \
        -Dkernelpkg=perfmon-682-x86_64.tar.gz \
        -Dkernel_version=2.6.28-rc3
</pre>

     <p>or with some more information (owner, topic):

     <pre class="verbatim">     
     artemis-testrun new \
       --owner=mhentsc3 \
       --topic=Kernel \
       --hostname=dickstone \
       --macroprecond=/data/bancroft/artemis/live/repository/macropreconditions/kernel/kernel_boot.mpc \
        -Dkernelpkg=perfmon-682-x86_64.tar.gz \
        -Dkernel_version=2.6.28-rc3
</pre>

</ul>

<p><strong>Person in charge</strong>: Steffen Schwigon

<h3 class="section">5.4 Producers</h3>

<p>Sometimes, parameters for preconditions shall be defined when the
testrun, this precondition is assigned to, is choosen for
execution. This might apply for example when you want to test the
newest build of a certain package. Also in combination with autorerun
testruns dynamic assignment of preconditions is useful. These testruns
are reinserted into the database automatically as soon as the
scheduler chooses them for execution. In this case dynamic
precondition assignment allows these rerun tests to differ
slightly. Preconditions with dynamically assigned parameters are
called lazy precondition (similar to the lazy evaluation technique).

<p>Dynamic precondition assignment is implemented using Precondition
Producers. A producer is a modul that is called by the scheduler for
handling of lazy preconditions. To use a lazy preconditio the user has
to assign a precondition of type &ldquo;producer&rdquo; to the testrun. This
precondition has to contain the basename of an existing producer
module and may contain additional parameters. The producer will
substitute the &ldquo;producer&rdquo; precondition with a normal precondition
that has values assigned to all parameters.

<h4 class="subsection">5.4.1 Lazy precondition</h4>

<p>Lets assume for example that you want to include the newest kernel
package into your test. This can be achieved with the existing
&ldquo;Kernel&rdquo; producer. Instead of a precondition of type &ldquo;package&rdquo;
with a certain filename you should assign the following precondition
to your testrun.

<pre class="verbatim">
precontition_type: producer
producer: Kernel 
</pre>

<p>This precondition will be substituted with a package precondition that
has the latest Sysint kernel build set as filename.

<h4 class="subsection">5.4.2 Producer API</h4>

<p>Producer are modules loaded into the scheduler. Thus they need to be
written in Perl and reside inside the
<code>Artemis::MCP::Scheduler::PreconditionProducer</code> namespace. A producer
has to implement a method &ldquo;produce&rdquo;. This function gets a job object
as first parameter and a hash containing all additional options from
the precondition as second parameter. It suggested that each producer
inherits from
<code>Artemis::MCP::Scheduler::PreconditionProducer</code>. Producers hall
return a hash that has the produced preconditions as YAML text
assigned to the hash key <code>precondition_yaml</code>. An optional key
<code>topic</code> allows the producer to set the topic for the test. If the
hash key <code>error</code> is set, the associated error string is reported
and the testrun is cancled. In this case the other hash keys are not
evaluated.

<div class="node">
<p><hr>
<a name="Commandline"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Web-User-Interface">Web User Interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Preconditions">Preconditions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Command line interface</h2>

<h3 class="section">6.1 SYNOPSIS</h3>

     <ul>
<li>Get host usage/scheduling overview

     <li>Create hosts

     <li>Create queues

     <li>Create hosts/queue bindings

</ul>

<h3 class="section">6.2 Scheduling: hosts, queues, jobs</h3>

<h4 class="subsection">6.2.1 Create new queue, new host, bind both together</h4>

     <ul>
<li>Show existing queues with priorities

     <pre class="verbatim">     
     artemis@bancroft:~> artemis-testrun listqueue -v
             10 |              AdHoc |  1000
             11 |      kernel_reboot |   100
              4 | xen-3.3-testing-32 |   100
              5 | xen-3.3-testing-64 |   100
              7 | xen-3.4-testing-32 |   100
              6 | xen-3.4-testing-64 |   100
              9 |    xen-unstable-32 |   100
              8 |    xen-unstable-64 |   100
</pre>

     <li>Create new queue <em>oprofile</em>

     <pre class="verbatim">     
     artemis@bancroft:~> artemis-testrun newqueue --name=oprofile --priority=200
     12
</pre>

     <li>Create new host <em>bullock</em> and bind it to queue <em>oprofile</em>

     <pre class="verbatim">     
     artemis@bancroft:~> artemis-testrun newhost --name=bullock --queue=oprofile
     10
</pre>

     <li>Show existing hosts

     <p>Note that the new host <em>bullock</em> is initially deactivated.

     <pre class="verbatim">     
     artemis@bancroft:~> artemis-testrun listhost -v
              8 |  amarok | deactivated |   free
              1 |  athene |      active | in use
              9 |   azael | deactivated |   free
             10 | bullock | deactivated |   free | oprofile
              4 |    cook | deactivated |   free
              6 | incubus | deactivated |   free
              2 |  kobold |      active | in use
              5 |  lemure |      active | in use
              3 |   satyr |      active | in use
              7 |    uruk | deactivated |   free
</pre>

     <li>Activate host <em>bullock</em>

     <p>Note that this command is ID based (bullock has id 10) because you
can rename hosts.

     <pre class="verbatim">     
     artemis@bancroft:~> artemis-testrun updatehost --id=10 --active
     10 | bullock | active | free | oprofile
</pre>

     <li>Again, show existing hosts

     <p>Host <em>bullock</em> is now activated.

     <pre class="verbatim">     
     artemis@bancroft:~> artemis-testrun listhost -v
              8 |  amarok | deactivated |   free
              1 |  athene |      active | in use
              9 |   azael | deactivated |   free
             10 | bullock |      active |   free | oprofile
              4 |    cook | deactivated |   free
              6 | incubus | deactivated |   free
              2 |  kobold |      active | in use
              5 |  lemure |      active | in use
              3 |   satyr |      active | in use
              7 |    uruk | deactivated |   free
</pre>

</ul>

<p>Done.

<h4 class="subsection">6.2.2 Change queue priority</h4>

     <ul>
<li>List existing queues

     <pre class="verbatim">     
     artemis@bancroft:~> artemis-testrun listqueue -v
             10 |              AdHoc |  1000
             11 |      kernel_reboot |   100
             12 |           oprofile |   200 | bullock
              4 | xen-3.3-testing-32 |   100
              5 | xen-3.3-testing-64 |   100
              7 | xen-3.4-testing-32 |   100
              6 | xen-3.4-testing-64 |   100
              9 |    xen-unstable-32 |   100
              8 |    xen-unstable-64 |   100
</pre>

     <li>Update queue

     <pre class="verbatim">     
     artemis@bancroft:~> artemis-testrun updatequeue --name=oprofile --priority=1000
     12
</pre>

     <li>Again, list existing queues

     <pre class="verbatim">     
     artemis@bancroft:~> artemis-testrun listqueue -v
             10 |              AdHoc |  1000
             11 |      kernel_reboot |   100
             12 |           oprofile |  1000 | bullock
              4 | xen-3.3-testing-32 |   100
              5 | xen-3.3-testing-64 |   100
              7 | xen-3.4-testing-32 |   100
              6 | xen-3.4-testing-64 |   100
              9 |    xen-unstable-32 |   100
              8 |    xen-unstable-64 |   100
</pre>

     <p>Done.

</ul>

<p><strong>Person in charge</strong>: Maik Hentsche

<div class="node">
<p><hr>
<a name="Web-User-Interface"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reports-API">Reports API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Commandline">Commandline</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Web User Interface</h2>

<p>The Web User Interface is a frontend to the Reports database. It
allows to overview reports that came in from several machines, in
several test suites.

<p>It can filter the results by dates, machines or test suite, gives
colorful (RED/YELLOW/GREEN) overview about success/failure ratios,
allows to zoom into details of single reports.

<p>To evaluate reported test results in a more programmatic way, have a
look into the <em>DPath Query Language</em> that is part of the
<a href="#Reports_003a_003aAPI">Reports::API</a>.

<h3 class="section">7.1 Usage</h3>

<p>The main URL is

<pre class="example">     <a href="http://osrc.amd.com/artemis">http://osrc.amd.com/artemis</a>
</pre>
<h3 class="section">7.2 Understanding Artemis Details</h3>

<h4 class="subsection">7.2.1 Part 1 Overview</h4>

     <ul>
<li>Go to <a href="https://osrc.amd.com/artemis/reports">https://osrc.amd.com/artemis/reports</a>

     <li>Click &ldquo;Last weeks test reports&rdquo;,
  aka. <a href="https://osrc.amd.com/artemis/reports/date/7">https://osrc.amd.com/artemis/reports/date/7</a>

     <li>Below day &ldquo;Wed Oct 7, 2009&rdquo; find the line

     <pre class="verbatim">     
         20856  2009-10-07  Topic-xen-unstable  satyr  PASS testrun 9617
</pre>

     <p>To find this report you probably need to go more back into the past
  than just 7 days, or you use the direct link below.

     <li>Note that there are other reports in this group that are greyed-out,
  i.e. all report ids of this testrun are:

     <pre class="verbatim">     
         20856    Topic-xen-unstable
         20855    LMBench
         20854    CTCS
         20852    Host-Overview
         20851    Hardwaredb Overview
</pre>

     <li>Note that something FAILed in the CTCS run (20854).

     <li>What we know until here:

          <ul>
<li>It is a test for Xen-unstable (Topic-xen-unstable)

          <li>The running of the guests+suites itself worked well (20856 PASS)

          <li>There were 2 guest runs:

          <pre class="verbatim">          
                  LMBench      satyr:celegorm.osrc.amd.com     PASS
                  CTCS         satyr:eriador                   FAIL
     </pre>

     </ul>

     <li>Click on the ID link &ldquo;20856&rdquo;
  aka. <a href="https://osrc.amd.com/artemis/reports/id/20856">https://osrc.amd.com/artemis/reports/id/20856</a>

</ul>

<h4 class="subsection">7.2.2 Part 2 Details</h4>

     <ul>
<li>Here you see the details of this report 20856.

     <p>You see:

          <ul>
<li>green PASSED results for the &ldquo;MCP overview&rdquo;. 
      This means the starting and finishing of the guests worked.

          <li>attachments of console logs.

          <li>some links to more information (raw TAP report, preconditions)

     </ul>

     <li>Note below the group of all the other reports, again it's the group
  of those IDs:

     <pre class="verbatim">     
         20856    Topic-xen-unstable
         20855    LMBench
         20854    CTCS
         20852    Host-Overview
         20851    Hardwaredb Overview
</pre>

     <li>The most meta information is in &ldquo;20852 Host-Overview&rdquo;.

     <li>Click on the ID link &ldquo;20852&rdquo;
  aka. <a href="https://osrc.amd.com/artemis/reports/id/20852">https://osrc.amd.com/artemis/reports/id/20852</a>

     <li>Now you see the details of &ldquo;20852 Host-Overview&rdquo; with
lots of meta information as &ldquo;Context&rdquo;.

     <p>You see:

     <pre class="verbatim">     
       Metainfo
           cpuinfo: 	1x Family: 15, Model: 67, Stepping: 2
           ram: 	3950 MB
           uptime: 	0 hrs
     
       XEN-Metainfo
           xen_dom0_kernel: 	2.6.18.8-xen x86_64
           xen_base_os_description: 	SUSE Linux Enterprise Server 10 SP2 (x86_64)
           xen_changeset: 	20273:10cfcbef68ee
           xen_version: 	3.5-unstable
     
       guest_1_redhat_rhel5u4_32bpae_qcow
           xen_guest_description: 	001-lmbench
           xen_guest_flags: 	
           xen_guest_start: 	
     
       guest_2_suse_sles10_sp3_gmc_32b_up_qcow
           xen_guest_description: 	002-ctcs
           xen_guest_flags: 	
           xen_guest_start: 	
</pre>

     <li>If you are interested in what went wrong in the CTCS run,
  click on ID link &ldquo;20854&rdquo;
  aka. <a href="https://osrc.amd.com/artemis/reports/id/20854">https://osrc.amd.com/artemis/reports/id/20854</a>

     <li>Here you see

          <ul>
<li>one RED bar in CTCS-results

          <li>several RED bars in var_log_messages

     </ul>

     <p>You can click on them to unfold the details.

</ul>

<h4 class="subsection">7.2.3 Part 3 Testrun</h4>

     <ul>
<li>Imagine that the testrun completely failed and no usable reports
  arrived in, except that primary one from the MCP, then you can use the
  link at the end of the line

     <pre class="verbatim">     
         20856  2009-10-07  Topic-xen-unstable  satyr  PASS testrun 9617
                                                            ------------ 
</pre>

     <li>Click on that link &ldquo;testrun 9617&rdquo;
  aka. <a href="https://osrc.amd.com/artemis/testruns/id/9617">https://osrc.amd.com/artemis/testruns/id/9617</a>

     <li>That contains the description what was <strong>planned</strong>
in this testrun, regardless of whether it succeeded.

     <p>(That's the main difference between the two complementary concepts
&ldquo;Testrun&rdquo; vs. &ldquo;Reports&rdquo;. The &ldquo;Testrun&rdquo; contains the
specification, the &ldquo;Reports&rdquo; contain the results.)

     <p>You see:

     <pre class="verbatim">     
       Name                  Automatically generated Xen test
       Host
           Architecture      linux64
           Root image        /suse_sles10_sp2_64b_smp_raw.tar.gz
           Test              metainfo
       Guest number 1
           Architecture      linux32
           Root image        /redhat_rhel5u4_32bpae_qcow.img
           Test              py_lmbench
       Guest number 2
           Architecture 	linux32
           Root image 	/suse_sles10_sp3_gmc_32b_up_qcow.img
           Test              py_ctcs
</pre>

     <li>That's it, basically.

</ul>

<div class="node">
<p><hr>
<a name="Reports-API"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Complete-Use_002dCases">Complete Use-Cases</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Web-User-Interface">Web User Interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<p><a name="Reports_003a_003aAPI"></a>

<h2 class="chapter">8 Reports::API</h2>

<!-- ====================================================================== -->
<h3 class="section">8.1 Overview</h3>

<p>There runs yet another daemon, the so called
<code>Artemis::Reports::API</code>, on the same host where already the
<code>TAP Receiver</code> runs. This &lsquo;<samp><span class="samp">Reports API</span></samp>&rsquo; is meant for
everything that needs more than just dropping TAP reports to a port,
e.g., some interactive dialog or parameters.

<p>This <code>Artemis::Reports::API</code> listens on Port <code>7358</code>. Its API
is modeled after classic unix script look&amp;feel with a first line
containing a description how to interpret the rest of the lines.

<p>The first line consists of a shebang (<code>#!</code>), a <dfn>api command</dfn>
and <dfn>command parameters</dfn>. The rest of the file is the
<dfn>payload</dfn> for the <dfn>api command</dfn>.

<p>The syntax of the &lsquo;<samp><span class="samp">command params</span></samp>&rsquo; varies depending on the
&lsquo;<samp><span class="samp">api command</span></samp>&rsquo; to make each command intuitively useable. Sometimes
they are just positional parameters, sometimes they look like the
start of a HERE document (i.e., they are prefixed with <code>&lt;&lt;</code> as
you can see below).

<p><strong>Person in charge</strong>: Steffen Schwigon

<!-- ====================================================================== -->
<h3 class="section">8.2 Raw API Commands</h3>

<p>In this section the raw API is described. That's the way you can use
without any dependencies except for the minimum ability to talk to a
port, e.g., via <code>netcat</code>.

<p>See section <a href="#artemis_002dapi">artemis-api</a> for how to use a dedicated command line
utility that makes talking to the reports API easier, but is a
dependency that might not be available in your personal test
environment.

<!--  -->
<h4 class="subsection">8.2.1 upload - attach a file to a report</h4>

<p>This api command lets you upload files, aka. attachments, to
reports. These files are available later through the web
interface. Use this to attach log files, config files or console
output.

<h5 class="subsubsection">8.2.1.1 Synopsis</h5>

<pre class="verbatim">
#! upload REPORTID FILENAME [ CONTENTTYPE ]
payload
</pre>

<h5 class="subsubsection">8.2.1.2 Parameters</h5>

     <ul>
<li>REPORTID

     <p>The id of the report to which the file is assigned

     <li>FILENAME

     <p>The name of the file

     <li>CONTENTTYPE

     <p>Optional MIME type; defaults to <code>plain</code>; use
<code>application/octet-stream</code> to make it downloadable later in
browser.

</ul>

<h5 class="subsubsection">8.2.1.3 Payload</h5>

<p>The raw content of the file to upload.

<h5 class="subsubsection">8.2.1.4 Example usage</h5>

<p>Just <code>echo</code> the first api-command line and then immediately
<code>cat</code> the file content:

<pre class="verbatim">
$ ( echo "#! upload 552 xyz.tmp" ; cat xyz.tmp ) | netcat -w1 bascha 7358
</pre>

<!--  -->
<h4 class="subsection">8.2.2 mason - Render templates with embedded query language</h4>

<p>To query report results we provide sending templates to the API in
which you can use a query language to get report details: This
api-command is called like the template engine so that we can provide
other template engines as well.

<h5 class="subsubsection">8.2.2.1 Synopsis</h5>

<pre class="verbatim">
#! mason debug=0 &lt;&lt;ENDMARKER
payload
ENDMARKER
</pre>

<h5 class="subsubsection">8.2.2.2 Parameters</h5>

     <ul>
<li>debug=1

     <p>If &lsquo;<samp><span class="samp">debug</span></samp>&rsquo; is specified and value set to 1 then any error message
that might occur is reported as result content. If debug is omitted or
false and an error occurs then the result is just empty.

     <li>&lt;&lt;ENDMARKER

     <p>You can choose any word instead of ENDMARKER which should mark the end
of input, like in HERE documents, usually some word that is not
contained in the template payload.

</ul>

<h5 class="subsubsection">8.2.2.3 Payload</h5>

<p>A mason template.

<p><dfn>Mason</dfn> is a template language, see
<a href="http://masonhq.com">http://masonhq.com</a>. Inside the template we provide a function
<code>reportdata</code> to access report data via a query language. See
section <a href="#Query-language">Query language</a> for details about this.

<h5 class="subsubsection">8.2.2.4 Example usage</h5>

<p>This is a raw Mason template:

<pre class="verbatim">
 % my $world = "Mason World";
 Hello &lt;% $world %>!
 % my @res = reportdata '{ "suite.name" => "perfmon" } :: //tap/tests_planned';
 Planned perfmon tests:
 % foreach (@res) {
    &lt;% $_ %>
 % }
</pre>

<p>If you want to submit such a Mason template you can add the
api-command line and the EOF marker like this:

<pre class="verbatim">
$ EOFMARKER="MASONTEMPLATE".$$
$ payload_file="perfmon_tests_planned.mas"
$ ( echo "#! mason &lt;&lt;$EOFMARKER" ; cat $payload_file ; echo "$EOFMARKER" ) \
    | netcat -w1 bascha 7358
</pre>

<p>The output of this is the rendered template. You can extend the line
to save the rendered result into a file:

<pre class="verbatim">
$ ( echo "#! mason &lt;&lt;$EOFMARKER" ; cat $payload_file ; echo "$EOFMARKER" ) \
    | netcat -w1 bascha 7358 > result.txt
</pre>

<p>The answer for this looks like this:

<pre class="verbatim">
Hello Mason World!
Planned perfmon tests:
   3
   4
   17
</pre>

<p><a name="Query-language"></a>

<h3 class="section">8.3 Query language DPath</h3>

<p>The query language, which is the argument to the <code>reportdata</code> as
used embedded in the &lsquo;<samp><span class="samp">mason</span></samp>&rsquo; examples above:

<pre class="verbatim">
 reportdata '{ "suite.name" => "perfmon" } :: //tap/tests_planned'
</pre>

<p>consists of 2 parts, divided by the &lsquo;<samp><span class="samp">::</span></samp>&rsquo;.

<p>We call the first part in braces <em>reports filter</em> and the second
part <em>data filter</em>.

<h4 class="subsection">8.3.1 Reports Filter (SQL::Abstract)</h4>

<p>The <em>reports filter</em> selects which reports to look at. The
expression inside the braces is actually a complete
<code>SQL::Abstract</code> expression
(<a href="http://search.cpan.org/~mstrout/SQL-Abstract/">http://search.cpan.org/~mstrout/SQL-Abstract/</a>) working
internally as a <code>select</code> in the context of the object relational
mapper, which targets the table <code>Report</code> with an active JOIN to
the table <code>Suite</code>.

<p>All the matching reports are then taken to build a data structure for
each one, consisting of the table data and the parsed TAP part which
is turned into a data structure via <code>TAP::DOM</code>
(<a href="http://search.cpan.org/~schwigon/TAP-DOM/">http://search.cpan.org/~schwigon/TAP-DOM/</a>).

<p>The <em>data filter</em> works then on that data structure for each
report.

<h5 class="subsubsection">8.3.1.1 SQL::Abstract expressions</h5>

<p>The filter expressions are best described by example:

     <ul>
<li>Select a report by ID
<pre class="verbatim">     
     { 'id' => 1234 }
</pre>

     <li>Select a report by suite name
<pre class="verbatim">     
     { 'suite_name' => 'oprofile' }
</pre>

     <li>Select a report by machine name
<pre class="verbatim">     
     { 'machine_name' => 'bascha' }
</pre>

     <li>Select a report by date

     <p>Here the value that you want to select is a structure by itself,
consisting of the comparison operator and a time string:

     <pre class="verbatim">     
     { 'created_at' => { '&lt;', '2009-04-09 10:00' }  }
</pre>

</ul>

<h5 class="subsubsection">8.3.1.2 The data structure</h5>

<h4 class="subsection">8.3.2 Data Filter (Data::DPath)</h4>

<p>The data structure that is created for each report can be evaluated
using the <em>data filter</em> part of the query language, i.e.,
everything after the <code>::</code>. This part is passed through to
<code>Data::DPath</code>
(<a href="http://search.cpan.org/~schwigon/Data-DPath/">http://search.cpan.org/~schwigon/Data-DPath/</a>).

<h5 class="subsubsection">8.3.2.1 Data::DPath expressions</h5>

<h4 class="subsection">8.3.3 Optimizations</h4>

<p>Using the query language can be slow. The biggest slowdown occurs with
the &lsquo;<samp><span class="samp">ANYWHERE</span></samp>&rsquo; element <code>//</code>, again with several of them,
because they span up a big search tree.

<p>Therefore, if you know the depth of your path, try to replace the
<code>//</code> with some <code>*</code> because that only spans up on the current
step not every possible step, like this:

<pre class="verbatim">
  { ... } :: //section/stats-proc-interrupts-before//tap//data/TLB";
</pre>

<pre class="verbatim">
  { ... } :: /results/*/section/stats-proc-interrupts-before/tap/lines/*/_children/*/data/TLB";
</pre>

<!-- ====================================================================== -->
<p><a name="artemis_002dapi"></a>

<h3 class="section">8.4 Client Utility <code>artemis-api</code></h3>

<p>There is a command line utility <code>artemis-api</code> that helps with
using the API without the need to talk the protocol and fiddle with
<code>netcat</code> by yourself.

<h4 class="subsection">8.4.1 help</h4>

<p>You can aquire a help page to each sub command:

<pre class="verbatim">
$ /home/artemis/perl510/bin/artemis-api help upload
</pre>

<p>prints

<pre class="verbatim">
artemis-api upload --reportid=s --file=s [ --contenttype=s ]
   --verbose          some more informational output
   --reportid         INT; the testrun id to change
   --file             STRING; the file to upload, use '-' for STDIN
   --contenttype      STRING; content-type, default 'plain', 
                      use 'application/octed-stream' for binaries
</pre>

<h4 class="subsection">8.4.2 upload</h4>

<p>Use it from the Artemis path, like:

<pre class="verbatim">
$ /home/artemis/perl510/bin/artemis-api upload \
  --file /var/log/messages \
  --reportid=301
</pre>

<p>You can also use the special filename <samp><span class="file">-</span></samp> to read from STDIN,
e.g., if you need to pipe the output of tools like <code>dmesg</code>:

<pre class="verbatim">
$ dmesg | /home/artemis/perl510/bin/artemis-api upload \
  --file=- \
  --filename dmesg \
  --reportid=301
</pre>

<h4 class="subsection">8.4.3 mason</h4>

<p>TODO

<div class="node">
<p><hr>
<a name="Complete-Use-Cases"></a>
<a name="Complete-Use_002dCases"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="#Artemis-Development">Artemis Development</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reports-API">Reports API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Complete Use-Cases</h2>

<p>In this chapter we describe how the single features are put together
into whole use-cases.

<h3 class="section">9.1 Automatic Xen testing</h3>

<p>This is a description on how to run Xen tests with <em>Artemis</em> using
<code>SLES10</code> with one <code>RHEL5.2</code> guest (64 bit) as an example.

<p>The following mainly applies to <b>manually</b> assigning Xen tests. The
SysInt team uses <em>temare</em> to automatically create the here
described steps.

<h4 class="subsection">9.1.1 Paths</h4>

     <ul>
<li>Host <strong>bancroft</strong>: /data/bancroft/artemis/live/

     <li>Host <strong>osko</strong>: /export/image_files/official_testing/

</ul>

<h4 class="subsection">9.1.2 Choose an image for Dom0 and images for each guest</h4>

<p>We use suse/suse_sles10_64b_smp_raw.tar.gz as Dom0 and

<pre class="verbatim">

 osko:/export/image_files/official_testing/raw_img/redhat_rhel5u2_64b_smp_up_small_raw.img

</pre>

<p>as the only guest.

<p>The SuSE image is of precondition type image. Thus its path is
relative to <code>/mnt/images</code> which has
<code>bancroft:/data/bancroft/artemis/live/repository/images/</code>
mounted.

<p>The root partition is named in the section &lsquo;<samp><span class="samp">root</span></samp>&rsquo; of the Xen
precondition. Furthermore, you need to define the destination
partition to be Dom0 root. We use <code>/dev/sda2</code> as an example. The
partition could also be named using its UUID or partition label. Thus
you need to add the following to the dom0 part of the Xen precondition:

<pre class="verbatim">

  root: 
    precondition_type: image
    mount: / 
    image: suse/suse_sles10_64b_smp_raw.tar.gz 
    partition: /dev/sda2

</pre>

<p>The RedHat image is of type &lsquo;<samp><span class="samp">copyfile</span></samp>&rsquo;.

<p>It is copied from
<code>osko:/export/image_files/official_testing/raw_img/</code> which is
mounted to <code>/mnt/nfs</code> before.

<p>This mounting is done automatically because the protocol type nfs is
given. The image file is copied to the destination named as dest in
the &lsquo;<samp><span class="samp">copyfile</span></samp>&rsquo; precondition. We use <code>/xen/images/</code> as an
example. To allow the System Installer to install preconditions into
the guest image, the file to mount and the partition to mount need to
be named. Note that even though in some cases, the mountfile can be
determined automatically, in other cases this is not possible
(e.g. when you get it from a tar.gz package). The resulting root
secition for this guest is:

<pre class="verbatim">
 
   root:
     precondition_type: copyfile
     name: osko:/export/image_files/official_testing/raw_img/redhat_rhel5u2_64b_smp_up_small_raw.img
     protocol: nfs
     dest: /xen/images/
     mountfile: /xen/images/redhat_rhel5u2_64b_smp_up_small_raw.img
     mountpartition: p1

</pre>

<h4 class="subsection">9.1.3 PRC configuration</h4>

<p>PRC (Program Run Control) is responsible for starting guests and test
suites.

<h5 class="subsubsection">9.1.3.1 Guest Start Configuration</h5>

<p>Making PRC able to start Xen guests is very simple. Every guest entry
needs to have a section named "config". In this section, a
precondition describing how the config file is installed and a
filename have to be given. As for guest images the file name is needed
because it can't be determined in some cases. We use 001.svm installed
via copyfile to /xen/images/001.svm. The resulting config section is:

<pre class="verbatim">
 
     config:
       precondition_type: copyfile
       name: /usr/share/artemis/packages/mhentsc3/001.svm
       protocol: local
       dest: /xen/images/
       filename: /xen/images/001.svm

</pre>

<h5 class="subsubsection">9.1.3.2 Testsuite Configuration</h5>

<p>You need to define, where you want which test suite to run. This can
be done in every guest and the Dom0. In this example, the Dom0 and the
single guest will run different testsuites. this chapter only
describes the Dom0 test program. See the summary at the end for
details on the guest test program.

<p>The section testprogram consists of a precondition definition
describing how the test suite is installed. In our example we use a
precondition type package with a relative path name. This path is
relative to
&rdquo;'/data/bancroft/artemis/live/repository/packages/&rdquo;'. Since
&rdquo;'bancroft:/data/bancroft/&rdquo;' is mounted to &rdquo;'/data/bancroft/&rdquo;' in
the install system, this directory can be accessed at
&rdquo;'bancroft:/data/bancroft/artemis/live/repository/packages/&rdquo;'.

<p>Beside the precondition you need to define an execname which is the
full path name of the file to be executed (remember, it can't be
determined). This file is called in the root directory (&rdquo;'/&rdquo;') in
the test system thus in case you need to use relative paths inside
your test suite they need to be relative to this. The program may take
parameters which are named in the optional array &rdquo;'parameters&rdquo;' and
taken as is. The parameter is &rdquo;'timeout_after_testprogram&rdquo;' which
allows you to define that your test suite shall be killed (and an
error shall be reported) after that many seconds. Even though this
parameter is optional, leaving it out will result in Artemis waiting
forever if your test doesn't send finish messages. The resulting
testprogram section looks like this:

<pre class="verbatim">
 
   testprogram:
     precondition_type: package
     filename: artemis-testsuite-system.tar.gz
     path: mhentsc3/
     timeout_after_testprogram: ~
     execname: /opt/system/bin/artemis_testsuite_system.sh 
     parameters: 
       - --report

</pre>

<h4 class="subsection">9.1.4 Preconditions</h4>

<p>Usually your images will not have every software needed for your tests
installed. In fact the example images now do but for the purpose of
better explanation we assume that we need to install dhcp, python-xml
and bridge-utils in Dom0. Furthermore we need a script to enable
network and console. At last we install the Xen package and a Xen
installer package. These two are still needed on our test
images. Package preconditions may have a &rdquo;'scripts&rdquo;' array attached
that name a number of programs to be executed after the package was
installed. This is used in our example to call the Xen installer
script after the Xen package and the Xen installer package were
installed. See the summary at the end for the resulting precondition
section.  The guest image only needs a DHCP client. Since this
precondition is appended to the precondition list of the appropriate
guest entry, the System Installer will automatically know that the
guest image has to be mounted and the precondition needs to be
installed inside relative to this mount.

<h4 class="subsection">9.1.5 Resulting YAML config</h4>

<p>After all these informations are gathered, put the following YAML text
into a file. We use /tmp/xen.yml as an example.

<pre class="verbatim">
 
   precondition_type: xen
   name: SLES 10 Xen with RHEL5.2 guest (64 bit)
   dom0:
     root:
       precondition_type: image
       mount: /
       image: suse/suse_sles10_64b_smp_raw.tar.gz
       partition: /dev/sda2
     testprogram:
       precondition_type: package
       filename: artemis-testsuite-system.tar.gz
       path: mhentsc3/
       timeout_after_testprogram: 3600
       execname: /home/artemis/x86_64/bin/artemis_testsuite_ctcs.sh
       parameters: 
         - --report
     preconditions:
       - precondition_type: package
         filename: dhcp-3.0.3-23.33.x86_64.rpm
         path: mhentsc3/sles10/
       - precondition_type: package
         filename: dhcp-client-3.0.3-23.33.x86_64.rpm
         path: mhentsc3/sles10/
       - precondition_type: package
         filename: python-xml-2.4.2-18.7.x86_64.rpm
         path: mhentsc3/sles10/
       - precondition_type: package
         filename: bridge-utils-1.0.6-14.3.1.x86_64.rpm
         path: mhentsc3/sles10/
   # has to come BEFORE xen because config done in here is needed for xens initrd
       - precondition_type: package
         filename: network_enable_sles10.tar.gz
         path: mhentsc3/sles10/
         scripts:
           - /bin/network_enable_sles10.sh
       - precondition_type: package
         filename: xen-3.2_20080116_1546_16718_f4a57e0474af__64bit.tar.gz
         path: mhentsc3/
         scripts: ~
       - precondition_type: package
         filename: xen_installer_suse.tar.gz
         path: mhentsc3/sles10/
         scripts:
           - /bin/xen_installer_suse.pl
   # only needed for debug purpose
       - precondition_type: package
         filename: console_enable.tar.gz
         path: mhentsc3/
         scripts:
           - /bin/console_enable.sh
   guests:
     - root:
         precondition_type: copyfile
         name: osko:/export/image_files/official_testing/raw_img/redhat_rhel5u2_64b_smp_up_small_raw.img
         protocol: nfs
         dest: /xen/images/
         mountfile: /xen/images/redhat_rhel5u2_64b_smp_up_small_raw.img
         mountpartition: p1
         #       mountpartition: /dev/sda3 # or label or uuid
       config:
         precondition_type: copyfile
         name: /usr/share/artemis/packages/mhentsc3/001.svm
         protocol: local
         dest: /xen/images/
         filename: /xen/images/001.svm
       testprogram:
         precondition_type: copyfile
         name: /usr/share/artemis/packages/mhentsc3/testscript.pl
         protocol: local
         dest: /bin/
         timeout_after_testprogram: 100
         execname: /bin/testscript.pl
       preconditions:
         - precondition_type: package
           filename: dhclient-4.0.0-6.fc9.x86_64.rpm
           path: mhentsc3/fedora9/

</pre>

<h4 class="subsection">9.1.6 Grub</h4>

<p>For Xen to run correctly, the defaults grub configuration is not
sufficient. You need to add another precondition to your test. System
Installer will replace $root with the /dev/ notation of the root
partition and $grubroot with the grub notation (including parenthesis)
of the root partition. Put the resulting precondition into a file. We
use /tmp/grub.yml as an example. This file may read like this:

<pre class="verbatim">
 
  precondition_type: grub
  config: |
   serial --unit=0 --speed=115200
   terminal serial
   timeout 3
   default 0
   title XEN-test
     root $grubroot
     kernel /boot/xen.gz com1=115200,8n1 console=com1
     module /boot/vmlinuz-2.6.18.8-xen root=$root showopts console=ttyS0,115200
     module /boot/initrd-2.6.18.8-xen 

</pre>

<h4 class="subsection">9.1.7 Order Testrun</h4>

<p>To order your test run with the previously defined preconditions you
need to stuff them into the database. Fortunatelly there are
commandline tools to help you with this job. They can be found at
&rdquo;'/home/artemis/perl510/bin/&rdquo;'. Production server for Artemis is
bancroft.amd.com. Log in to this server (as root, since user login
hasn't been thoroughly tested). Make sure that $ARTEMIS_LIVE is set to
1 and /home/artemis/perl510/bin/ is at the beginning of your $PATH (so
the correct perl will always be found). For each precondition you want
to put into the database you need to define a short name. Call
&rdquo;'/home/artemis/perl510/bin/artemis-testrun newprecondition&rdquo;' with
the appropriate options, e.g. in our example:

<pre class="verbatim">
 
  /home/artemis/perl510/bin/artemis-testrun newprecondition --shortname=grub --condition_file=/tmp/grub.yml
  /home/artemis/perl510/bin/artemis-testrun newprecondition --shortname=xen --condition_file=/tmp/xen.yml

</pre>

<p>C&lt;artemis-testrun&gt; will return a precondition ID in each case. You will
need those soon so please keep them in mind. In the example the
precondition id for grub is 4 and for Xen its 5.

<p>You can now put your test run into the database using
<code>/home/artemis/perl510/bin/artemis-testrun new</code>. This expects a
hostname, a test program and all preconditions. The test program is
never evaluated and only there for historical reasons. Put in anything
you like. root is not yet know to the database as a valid user. Thus
you need to add <code>--owner</code> with an appropriate user. The resulting
call looks like this:

<pre class="verbatim">

  /home/artemis/perl510/bin/artemis-testrun new \\
     --hostname=bullock --precondition=4 --precondition=5 \\
     --test_program=whatever --owner=mhentsc3
 
</pre>

<p>C&lt;artemis-testrun&gt; new has more optional arguments, one of them being
&ndash;earliest. This option defines when to start the test earliest. It
defaults to "now". When the requested time has arrived, Artemis will
setup the system you requested and execute your test run. Stay
tuned. When everything went well, you'll see test output soon. For
more information on what is going on with Artemis, see
/var/log/artemis-debug.

<p><strong>Person in charge</strong>: Maik Hentsche

<div class="node">
<p><hr>
<a name="Artemis-Development"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Complete-Use_002dCases">Complete Use-Cases</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 Artemis Development</h2>

<!-- ========================= -->
<p>This chapter is dedicated not to end users but to Artemis development.

<h3 class="section">10.1 Repositories</h3>

<!-- ================== -->
<p><em>Artemis</em> is developed using <em>git</em>. There is one central
repository to participate on the development

<pre class="verbatim">
 ssh://gituser@wotan/srv/gitroot/Artemis
</pre>

<p>and one mirrored public one:

<pre class="verbatim">
 git://osrc.amd.com/artemis.git
</pre>

<h3 class="section">10.2 Starting/Stopping Artemis server applications</h3>

<!-- =================================================== -->
<p>This chapter assumes all services are deployed, as described in
<a href="#Deployment">Deployment</a>.

<h4 class="subsection">10.2.1 Live environment</h4>

<!-- ========================= -->
<p>The live environment is based on the host <code>bancroft</code> for all the
server applications, like mysql db, Reports::Receiver, Reports::API,
Web User Interface, MCP.

<h5 class="subsubsection">10.2.1.1 Web User Interface</h5>

<!-- ============================== -->
<p>The application is configured inside the Apache config and therefore
only needs Apache to be (re)started. <code>/home/artemis</code> must be
mounted.

<pre class="verbatim">
 $ ssh root@bancroft
 $ rcapache2 restart
</pre>

<h5 class="subsubsection">10.2.1.2 Reports::Receiver</h5>

<pre class="verbatim">
 $ ssh root@bancroft
 $ /etc/init.d/artemis_reports_receiver_daemon restart
</pre>

<h5 class="subsubsection">10.2.1.3 Reports::API</h5>

<pre class="verbatim">
 $ ssh root@bancroft
 $ /etc/init.d/artemis_reports_api_daemon restart
</pre>

<h4 class="subsection">10.2.2 Development environment</h4>

<!-- ================================ -->
<p>The development environment is somewhat distributed.

<p>On host <code>bascha</code> there are mysql db, Reports::Receiver,
Reports::API, Web User Interface.

<p>The MCP is usually running on host <code>siegfried</code>, with a test
target machine <code>bullock</code>.

<h5 class="subsubsection">10.2.2.1 Preparing an MCP host</h5>

<pre class="verbatim">

 $ sudo apt-get install inetutils-inetd
 $ sudo apt-get install atftpd
 $ sudo chmod 777 /var/lib/tftpboot/
 $ sudo ln -s /var/lib/tftpboot /tftpboot
 $ # in /etc/group add group ``artemis'' with same ID as NFS group ``artemis'': 55435
 $ # add local user to this ``artemis'' group
 $ # needed to access /data/bancroft/artemis

</pre>

<h5 class="subsubsection">10.2.2.2 Web User Interface</h5>

<p>The application is running with its own webserver on <code>bascha</code>:

<pre class="verbatim">
 $ ssh ss5@bascha

 # kill running process
 $ kill `ps auxwww|grep artemis_reports_web_server | grep -v grep | awk '{print $2}' | sort | head -1`

 # restart
 $ sudo /etc/init.d/artemis_reports_web
</pre>

<h5 class="subsubsection">10.2.2.3 Reports::Receiver</h5>

<pre class="verbatim">
 $ ssh ss5@bascha
 $ sudo /etc/init.d/artemis_reports_receiver_daemon restart
</pre>

<h5 class="subsubsection">10.2.2.4 Reports::API</h5>

<pre class="verbatim">
 $ ssh ss5@bascha
 $ sudo /etc/init.d/artemis_reports_api_daemon restart
</pre>

<h4 class="subsection">10.2.3 Logfiles</h4>

<!-- ================= -->
<p>The applications write logfiles on these places:

     <ul>
<li>MCP (automation master control program)

     <pre class="verbatim">     
      /var/log/artemis-debug
</pre>

     <li>Reports::Receiver

     <pre class="verbatim">     
      /var/log/artemis_reports_receiver_daemon_stdout.log
      /var/log/artemis_reports_receiver_daemon_stderr.log
</pre>

     <li>Reports::API

     <pre class="verbatim">     
      /var/log/artemis_reports_api_daemon_stdout.log
      /var/log/artemis_reports_api_daemon_stderr.log
</pre>

</ul>

<p><a name="Deployment"></a>

<h3 class="section">10.3 Deployment</h3>

<!-- ================ -->
<p>This chapter is a collection of instructions how to build the
Artemis toolchain.

<p>The whole deployment process should be supported by a common build
system, however that is not yet completed but done via several
self-written build steps.

<h4 class="subsection">10.3.1 Create and upload Python packages</h4>

<!-- ========================================== -->
<p>This is usually done by a developer on some working state that is
worth to be installed in the development or live environment.

     <ul>
<li>Go to the development subdirectory of the package (lmbench wrapper in this example)

     <pre class="verbatim">     
      cd Artemis/src/TestSuite-LmBench-Python
</pre>

     <li>Call make to generate the package used for live or development

     <pre class="verbatim">     
      $ make devel
</pre>

     <p>or

     <pre class="verbatim">     
      $ make live
</pre>

</ul>

<h4 class="subsection">10.3.2 Create and upload Perl packages</h4>

<!-- ======================================== -->
<p>For <code>Artemis::MCP</code>, <code>Artemis::PRC</code>,
<code>Artemis::Installer</code>, <code>Artemis::Schema</code> and
<code>Artemis::Config</code> the deployment also works via <code>make
devel/live</code>:

     <ul>
<li><pre class="verbatim">     
      $ make devel
</pre>

     <p>or

     <pre class="verbatim">     
      $ make live
</pre>

</ul>

<p>For the other Perl libraries of the Reports framework follow these
steps:

     <ul>
<li>Go to the subdirectory of the package (Reports API in this example)

     <pre class="verbatim">     
      $ cd Artemis/src/Artemis-Reports-API
</pre>

     <li>Call the Perl build steps to generate a distribution

          <ul>
<li>If <code>Module::Install</code> driven:

          <pre class="verbatim">          
           $ perl Makefile.PL
           $ make
           $ make test
           $ make dist
     </pre>

          <li>If <code>Module::Build</code> driven:

          <pre class="verbatim">          
           $ perl Build.PL
           $ ./Build
           $ ./Build test
           $ ./Build dist
     </pre>

     </ul>

     <p>Version numbers are not incremented automatically (as it can be done
with the Python wrappers). The VERSION upgrade needs to be done
manually before publicly uploading a new version.

     <li>Upload the package

     <pre class="verbatim">     
      $ ./scripts/dist_upload_wotan.sh
</pre>

</ul>

<h4 class="subsection">10.3.3 Generate complete Artemis toolchain in opt-artemis package</h4>

<!-- =================================================================== -->
<p>The previous chapters described how to build packages based on an
already prepared build environment.

<p>If you need to start from scratch the following section applies.

<p>Following are the steps to create a <code>opt-artemis.tar.gz</code> package
in a mounted and chrooted image. It compiles Perl and Python, installs
them under <code>/opt/artemis</code> and installs the Artemis libraries. For
the Perl part it also installs all CPAN dependencies from a local
mirror.

<p>The resulting <code>/opt/artemis</code> subdir can be used to continuously
upgrade the Artemis libs as described in the preceding sections.

     <ul>
<li>Login as User &lsquo;<samp><span class="samp">ss5</span></samp>&rsquo;

     <pre class="verbatim">     
      $ ssh ss5@bascha
</pre>

     <li>Copy base raw image to <code>/tmp</code>

     <p><strong>64bit:</strong>
<pre class="verbatim">     
      $ cp .../redhat_rhel4u7_64b_smp_qcow.img /tmp/
</pre>

     <p><strong>32bit:</strong>
<pre class="verbatim">     
      $ cp .../redhat_rhel4u7_32b_smp_qcow.img /tmp/
</pre>

     <li>These images have multiple images, mount them

     <pre class="verbatim">     
      $ sudo losetup /dev/loop1 /tmp/redhat_rhel4u7_64b_smp_raw.img
      $ sudo kpartx -a /dev/loop1 
      $ sudo mount /dev/mapper/loop1p2 /mnt
</pre>

     <li>Other images might have only one partition, mount them with

     <pre class="verbatim">     
      $ sudo mount -o loop /tmp/one_partion_image_raw.img /mnt
</pre>

     <li>Mount directories into the chroot

     <p>In this example we need <code>~ss5</code> as source for Perl and Python
builders and a bind mounted <code>/dev</code> to get a random seed for ssh
(used to fetch source).

     <pre class="verbatim">     
      $ sudo mkdir -p /mnt/home/ss5
      $ sudo mount -o bind /2home/ss5 /mnt/home/ss5
      $ sudo mount -o bind /dev/ /mnt/dev
      $ sudo mkdir /mnt/home/artemis
      $ sudo mount loge:/artemis /mnt/home/artemis
      $ sudo mount -t proc proc /mnt/proc
</pre>

     <li>Chroot into the image

     <p><strong>64bit:</strong>

     <pre class="verbatim">     
      $ sudo chroot /mnt bash -l
</pre>

     <p><strong>32bit:</strong>

     <pre class="verbatim">     
      $ linux32 sudo chroot /mnt bash -l
</pre>

     <li>Install git

     <p><strong>64bit:</strong>

     <pre class="verbatim">     
      $ rpm -ivh \
        ftp://ftp.tu-chemnitz.de/pub/linux/fedora-epel/4/x86_64/git-core-1.5.3.6-2.el4.x86_64.rpm \
        ftp://ftp.tu-chemnitz.de/pub/linux/fedora-epel/4/x86_64/perl-Git-1.5.3.6-2.el4.x86_64.rpm
</pre>

     <p><strong>32bit:</strong>

     <pre class="verbatim">     
      $ rpm -ivh \
        ftp://ftp.tu-chemnitz.de/pub/linux/fedora-epel/4/i386/git-core-1.5.3.6-2.el4.i386.rpm \
        ftp://ftp.tu-chemnitz.de/pub/linux/fedora-epel/4/i386/perl-Git-1.5.3.6-2.el4.i386.rpm
</pre>

     <li>Enable public key authentication for git

     <pre class="verbatim">     
      $ cp -r /home/ss5/.ssh/ /root/
</pre>

     <li>Bootstrap complete Artemis toolchain

     <pre class="verbatim">     
      $ cd /home/ss5/artemis-perl 
      $ ./bootstrap_artemis_perl.sh
</pre>

     <li><code>bootstrap_artemis_perl.sh</code> needs the user password for sudo, type it in

     <li>This creates the directory <code>/opt/artemis/</code> but without any current Artemis code

     <li>Copy Perl modules into <code>/opt/artemis</code>

     <pre class="verbatim">     
      $ rsync -r /home/artemis/perl510/lib/site_perl/5.10.0/Artemis/ \
                 /opt/artemis/lib/perl5/site_perl/5.10.0/Artemis/
</pre>

     <li>Go to <code>/home/artemis/PYTHONREPO</code>, execute <code>build_python.sh</code> there

     <pre class="verbatim">     
      $ cd /home/artemis/PYTHONREPO ./wrapper_install_opt.sh
</pre>

     <li>Pack opt file together

     <pre class="verbatim">     
      $ cd /mnt/mnt/artemis
      $ sudo tar -czf /tmp/opt-artemis64_rh4.7.tar.gz opt
</pre>

     <li>Copy package to <code>/data/bancroft</code>

     <pre class="verbatim">     
      $ sudo cp \
        /tmp/opt-artemis64_rh4.7.tar.gz \
        /data/bancroft/artemis/live/repository/packages/artemisutils/opt-artemis64_rh4.7.tar.gz
</pre>

</ul>

<p><strong>Person in charge</strong>: Maik Hentsche, Conny Seidel, Steffen Schwigon

<h4 class="subsection">10.3.4 Installation of the Web User Interface</h4>

<!-- =============================================== -->
<p>The web application itself is available via the NFS mounted
<code>/home/artemis</code>. On the application server in the Apache
webserver you only need to configure a Location for the path
<code>/artemis</code>.

<pre class="verbatim">
bancroft$ cat /etc/apache2/conf.d/artemis_reports_web.conf

Alias / /home/artemis/perl510/bin/artemis_reports_web_fastcgi_live.pl/
&lt;LocationMatch /artemis[.]*>
       Options ExecCGI
       Order allow,deny
       Allow from all
       AddHandler fcgid-script .pl
&lt;/LocationMatch>
</pre>

<p>Additionally there is a reverse proxy configured on
<code>osrc.amd.com</code> that points to the application server:

<pre class="verbatim">
osrc$ cat /etc/apache2/conf.d/artemis_reverse_proxy.conf

ProxyRequests Off
&lt;Proxy *>
    Order deny,allow
    Allow from all
&lt;/Proxy>
ProxyPass        /artemis http://bancroft/artemis
ProxyPassReverse /artemis http://bancroft/artemis
ProxyPass        /hardwaredb http://bancroft/hardwaredb
ProxyPassReverse /hardwaredb http://bancroft/hardwaredb

</pre>

<p><strong>Person in charge</strong>: Steffen Schwigon

<h3 class="section">10.4 Upgrading a database schema</h3>

<!-- ================================= -->
<p>The database schema is maintained as description for the Object
Relational Mapper <em>DBIx::Class</em> using some versioning and
upgrading features.

<p>Those features are accessible via the command line tool
<code>artemis-db-deploy</code>. The basic principle is:

<p>(We show it here for <code>ReportsDB</code> schema. Same applies for
<code>TestrunDB</code>.)

     <ul>
<li>Maintain schema in <code>src/Artemis-Schema/lib/Artemis/Schema/ReportsDB/Result/*.pm</code>

     <li>Upgrade schema version in <code>src/Artemis-Schema/lib/Artemis/Schema/ReportsDB.pm</code>

     <li>Upgrade package version in <code>src/Artemis-Schema/lib/Artemis/Schema.pm</code>

     <li>Install schema package on a development machine

     <li>Create a difference/upgrade file relative to an old version

     <pre class="verbatim">     
      cd src/Artemis-Schema/
      artemis-db-deploy makeschemadiffs \
                        --db=ReportsDB \
                        --fromversion=2.010021 \
                        --upgradedir=./upgrades/
</pre>

     <p>In this example the version <code>2.010021</code> is the existing
version. Do this for every version that you will later
upgrade. Usually that's just the last one, but maybe you have several
machines with different versions and want to upgrade them to this new
version, then you need to call above line with all those old
&ndash;fromversion's.

     <p>Of course you also can upgrade them in single steps from any old
version via all intermediate versions to the latest. This is probably
the best solution anyway.

     <li>Add the diff/upgrade files to revision control

     <pre class="verbatim">     
      git add ./upgrades/
      git commit -m'Schema: db upgrade files'
</pre>

     <li>Copy the diff/upgrade files to the target machine

     <p>For some reason, the &ndash;upgradedir option does not work on the upcoming
<code>upgrade</code> command but only the default subdir <code>var/tmp</code>, so
you always need to copy the upgrade files, but only discriminate
between development machine or the live machine.

     <pre class="verbatim">     
      rsync --progress -rc ./upgrades/ /var/tmp/
</pre>

     <p>or

     <pre class="verbatim">     
      rsync --progress -rc ./upgrades/ bancroft:/var/tmp/
</pre>

     <li>Upgrade the schema.

     <p>Which environment and therefore which db connection is used depends on
the environment. On development machine I have set

     <pre class="verbatim">     
      export ARTEMIS_DEVELOPMENT=1
</pre>

     <p>Then you just call

     <pre class="verbatim">     
      artemis-db-deploy upgrade --db=ReportsDB
</pre>

</ul>

<h3 class="section">10.5 Environment variables</h3>

<!-- =========================== -->
<p>There are some environment variables used in several contexts. Some of
them are set from the automation layer to support the testsuites, some
of them are used to discriminate between development and live context
and some are just auxiliary variables to switch features.

<p>Keep in mind that the variable needs to be visible where the actual
component is running, which is sometimes not obvious in the
client/server infrastructure.

     <ul>
<li>ARTEMIS_TESTRUN

     <p>Set by the automation layer for the test suites which in turn should
use it in there reports.

     <li>ARTEMIS_SERVER

     <p>Set by the automation layer for the test suites. Specifies the
controlling host which initiated the testrun.

     <li>ARTEMIS_REPORT_SERVER

     <p>Set by the automation layer for the test suites. Specifies to which
server the reports should be sent.

     <li>ARTEMIS_REPORT_PORT

     <p>Set by the automation layer for the test suites. Specifies to which
port the reports should be sent.

     <li>ARTEMIS_REPORT_API_PORT

     <p>Set by the automation layer for the test suites. Specifies on which
port the reports interface is listening, which is used, for instance,
for uploading files.

     <li>ARTEMIS_TS_RUNTIME

     <p>Set by the automation layer for the test suites. Specifies the
expected time that the testsuite should run. (Some suites, although
only taking 1 hour, are re-run again and again for a given timespan.)

     <li>ARTEMIS_NTP_SERVER

     <p>Set by the automation layer for the test suites. Specifies the NTP
server that the suite should use as reference for time shifting tests.

     <li>ARTEMIS_GUEST_NUMBER

     <p>Set by the automation layer for the test suites inside
guests. Specifies which number the guest is, so the suite can report
it and later this number helps sorting out results and context.

     <li>ARTEMIS_OUTPUT_PATH

     <p>Set and used by the automation layer. Specifies where the automation
layer stores files like, e.g., console logs which are later
uploaded. Can be used by the test suites; all files that they store
there are automatically uploaded at the end of the testrun.

     <li>ARTEMIS_DEVELOPMENT

     <p>Used by Artemis::Config to switch the config space. By this the whole
context of every module that is accessing the config in the same
environment is switched to either &ldquo;live&rdquo; or &ldquo;development&rdquo;. If not
set to a true value the LIVE context is used by default.

     <li>ARTEMIS_REPORTS_WEB_PORT

     <p>Used by the web user interface Artemis::Reports::Web. Specifies the
port on which it is running, usually only important for development
mode. Else it is accessed via the usual Apache HTTP port 80.

     <li>ARTEMIS_REPORTS_WEB_RELOAD

     <p>Used by the web user interface Artemis::Reports::Web. Specifies
whether the web application restarts if it recognizes changes in its
source files.

     <li>ARTEMIS_REPORTS_WEB_LIVE

     <p>Used by the web user interface Artemis::Reports::Web. Specifies
whether the config context either &ldquo;live&rdquo; or &ldquo;development&rdquo;.  It is
therefore similar to <code>ARTEMIS_DEVELOPMENT</code> but the web user
interface is disconnected from the automation layer, even in the used
config, and therefore using its own mechanism.

</ul>

<h3 class="section">10.6 Files</h3>

<!-- =========== -->
<h4 class="subsection">10.6.1 Special files</h4>

<!-- ====================== -->
     <ul>
<li>/tmp/ARTEMIS_FORCE_NEW_TAPDOM

     <p>Used by the database layer. If this file exists the cached values of
TAP evaluation are thrown away and regenerated. This might be
neccessary when the Artemis::TAP::Harness or used sub parts like
TAP::DOM changed.

     <p>Do not forget to remove this file, because it dramtically slows down
all database TAP-DOM access!

     <li>/tmp/ARTEMIS_CACHE_CLEAR

     <p>Used by the Reports API. If this file exists the used caches are
flushed.

     <p>Do not forget to remove this file, because it dramtically slows down
all DPath queries.

     <p>It is suggested to just temporarily create it, trigger the API once so
it flushes the caches and immediately remove the file.

     <li>/tmp/FileCache

     <p>This is where the Reports API caches DPath requests. Delete it if you
want to flush the cache.

</ul>

<h4 class="subsection">10.6.2 PID files</h4>

<!-- ================== -->
     <ul>
<li>/tmp/artemis-reports-receiver-daemon.pid

     <p>Contains the Process ID of the reports receiver daemon.

     <li>/tmp/artemis-reports-api-daemon.pid

     <p>Contains the Process ID of the reports api daemon.

     <li>/tmp/artemis_mcp_runloopdaemon.pid

     <p>Contains the Process ID of the MCP runloop daemon.

</ul>

<h4 class="subsection">10.6.3 Log files</h4>

<!-- ================== -->
     <ul>
<li>/tmp/artemis_reports_web.log

     <p>Contains log of the Web user interface if it runs with own http
daemon, usually in DEVELOPMENT mode.

     <li>/var/log/apache2/error_log

     <p>Contains log of the Web user interface if it runs under Apache2,
usually in LIVE mode.

     <li>/tmp/artemis_mcp_stderr.log

     <p>Contains STDERR of the Master Control Program (MCP).

     <li>/tmp/artemis_mcp_stdout.log

     <p>Contains STDOUT of the Master Control Program (MCP).

     <li>/var/log/artemis_reports_api_daemon_stderr.log

     <p>Contains STDERR of the reports api daemon.

     <li>/var/log/artemis_reports_api_daemon_stdout.log

     <p>Contains STDOUT of the reports api daemon.

     <li>/var/log/artemis_reports_receiver_daemon_stderr.log

     <p>Contains STDERR of the reports receiver daemon.

     <li>/var/log/artemis_reports_receiver_daemon_stdout.log

     <p>Contains STDOUT of the reports receiver daemon.

</ul>

<h3 class="section">10.7 Image preparation</h3>

<!-- ======================= -->
<p>There are several assumptions about available features inside the os
images.

     <ul>
<li>netcat

     <p>There must be a <code>netcat</code> or <code>nc</code> available.

     <li>/etc/artemis

     <p>The file <code>/etc/artemis</code> must be writeable.

     <p>This is normally the case, but on some systems (non-writeable qcow
images) this requires that the file is a link to a file in another
writeable mounted image.

     <li>/opt/artemis

     <p>There directory <code>/opt/artemis</code> must be a writeable.

     <p>This is normally the case, but on some systems (non-writeable qcow
images) this requires that the file is a link to a file in another
writeable mounted image.

</ul>

<h3 class="section">10.8 temare - use a local temare</h3>

<!-- ================================= -->
<pre class="verbatim">

 mkdir ~/temare
 rsync -a ~/local/projects/Artemis/src/temare/ /2home/ss5/temare/
 cd ~/temare
 vi src/vi config.py
 mkdir -p config/{xen,kvm}
 cp /data/bancroft/artemis/live/configs/temare/test-schedule.db .
 ./temare subjectlist
 ./temare subjectstate kvm 64 enable
 ./temare subjectlist

</pre>

<h3 class="section">10.9 Host Forensics</h3>

<!-- ==================== -->
<h4 class="subsection">10.9.1 Investigate a host</h4>

<!-- =========================== -->
     <ul>
<li>after it was installed but something went wrong so it could not continue or

     <li>after it ran a test and it waits

</ul>

<h4 class="subsection">10.9.2 Console</h4>

<p>If ssh does not work, try to use the console.

<h4 class="subsection">10.9.3 View Artemis spec</h4>

<p>The spec what to run on that host is in <em>/etc/artemis</em>.

<p>In the following example you can see those details:

     <ul>
<li>testrun id 12430

     <li>execute /bin/artemis-testsuite-oprofile.sh

     <li>report result to bancroft:7357

     <li>MCP server is bancroft:37776

</ul>

<pre class="verbatim">
bullock:~ # cat /etc/artemis
---
hostname: bullock
mcp_server: bancroft
paths:
  autoinstall:
    grubfiles: /data/bancroft/artemis/live/repository/autoinstall/grubfiles/
  base_dir: /mnt/target/
  grubpath: /data/bancroft/artemis/live/configs/tftpboot
  guest_mount_dir: /mnt/guests/
  image_dir: /data/bancroft/artemis/live/repository/images/
  localdata_path: /tftpboot/
  nfskernel_path: /tftpboot/
  nfsroot: 165.204.15.71:/data/bancroft/artemis/live/nfsroot/installation_base/
  output_dir: /data/bancroft/artemis/live/output/
  package_dir: /data/bancroft/artemis/live/repository/packages/
  prc_nfs_mountdir: /data/bancroft/
  temare_path: /home/artemis/temare
  testprog_path: /data/bancroft/artemis/live/testprogram/
port: 37776
prc_nfs_server: bancroft
report_api_port: 7358
report_port: 7357
report_server: bancroft
test_run: 12430
testprogram_list:
  - program: /bin/artemis-testsuite-oprofile.sh
    timeout: 90
times:
  boot_timeout: 1200
  installer_timeout: 3600
  poll_intervall: 10
  reschedule_time: 3600
  test_runtime_default: 7200
</pre>

<h4 class="subsection">10.9.4 Restart the Artemis scripts on a waiting machine</h4>

<!-- ========================================================= -->
<p>The machine just ran a test but something in the scripts needs to be
fixed.

<p>You can edit the files in <em>/opt/artemis/bin/</em> and
<em>/opt/artemis/lib/</em> and then restart the whole testrun with:

<pre class="verbatim">
umount /data/bancroft/
/etc/init.d/artemis
</pre>

<h3 class="section">10.10 Troubleshooting</h3>

<!-- ===================== -->
<h4 class="subsection">10.10.1 Got a packet bigger than 'max_allowed_packet' bytes</h4>

<!-- ============================================================ -->
     <ul>
<li>Context:
mysql, usually via a Perl DBI driver.

     <li>Error message:

     <pre class="verbatim">     
     Artemis::Reports::DPath::Mason::render_template::exec(anon_comp): 
     DBIx::Class::DynamicDefault::update(): 
     DBI Exception: 
     DBD::mysql::st execute failed: 
     Got a packet bigger than 'max_allowed_packet' bytes
      [for Statement "UPDATE report SET tapdom = ?, updated_at = ? WHERE ( id = ? )" 
       with ParamValues: 0='$VAR1 = [
       {
         'section' => {
            'artemis-meta-information' => {
               'tap' => bless( {
                 'parse_errors' => [],
                    'tests_run' => 1,
                    'version' => 13,
                    'exit' => 0,
                    'start_time' => '1241791634.64412',
                    'skip_all' => undef,
                    'lines' => [
                       {
                         ...', 1='2009-05-08 14:07:14', 2='6033']
      at /home/artemis/perl510/lib/site_perl/5.10.0/
         Artemis/Schema/ReportsDB/Result/Report.pm line 132
     
     Stack:
       [/home/artemis/perl510/lib/site_perl/5.10.0/Carp/Clan.pm:213]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/Exception.pm:58]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/Schema.pm:1020]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/Storage.pm:122]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/Storage/DBI.pm:863]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/Storage/DBI.pm:1113]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/Storage/DBI.pm:608]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/Storage/DBI.pm:1123]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/Storage/DBI.pm:1206]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/Row.pm:325]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/Relationship/CascadeActions.pm:30]
       [/home/artemis/perl510/lib/site_perl/5.10.0/DBIx/Class/DynamicDefault.pm:117]
       [/home/artemis/perl510/lib/site_perl/5.10.0/Artemis/Schema/ReportsDB/Result/Report.pm:132]
       [/home/artemis/perl510/lib/site_perl/5.10.0/Artemis/Reports/DPath.pm:75]
       [/home/artemis/perl510/lib/site_perl/5.10.0/Artemis/Reports/DPath.pm:62]
       [/home/artemis/perl510/lib/site_perl/5.10.0/Artemis/Reports/DPath.pm:26]
       [/virtual/artemis_reports_dpath_mason:23]
</pre>

     <li>Fix:

     <p>Increase the buffer size in the mysql config, e.g., on <code>bancroft</code> in <code>/etc/my.cnf</code>:

     <pre class="verbatim">     
     [mysqld]
     ...
     max_allowed_packet = 128M
     ...
</pre>

</ul>

</div><!-- class="artemismanual"-->