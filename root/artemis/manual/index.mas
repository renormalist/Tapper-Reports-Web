<div class="artemismanual">
<h1 class="settitle">ARTEMIS User Manual</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Synopsis">Synopsis</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<ul class="menu">
<li><a accesskey="1" href="#Synopsis">Synopsis</a>
<li><a accesskey="2" href="#Technical-Infrastructure">Technical Infrastructure</a>
<li><a accesskey="3" href="#Test-Protocol">Test Protocol</a>
<li><a accesskey="4" href="#Test-Suite-Wrappers">Test Suite Wrappers</a>
<li><a accesskey="5" href="#Preconditions">Preconditions</a>
<li><a accesskey="6" href="#Command-line-interface">Command line interface</a>
<li><a accesskey="7" href="#Web-User-Interface">Web User Interface</a>
<li><a accesskey="8" href="#Reports-API">Reports API</a>
<li><a accesskey="9" href="#Complete-Use-Cases">Complete Use Cases</a>
</ul>

<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Synopsis" href="#Synopsis">1 Synopsis</a>
<ul>
<li><a href="#Synopsis">1.1 ARTEMIS infrastructure</a>
<li><a href="#Synopsis">1.2 Vocabulary</a>
<ul>
<li><a href="#Synopsis">1.2.1 Master Control Program (MCP)</a>
<li><a href="#Synopsis">1.2.2 Program Run Control (PRC)</a>
<li><a href="#Synopsis">1.2.3 Reports Receiver</a>
<li><a href="#Synopsis">1.2.4 Reports API</a>
<li><a href="#Synopsis">1.2.5 Web User Interface</a>
<li><a href="#Synopsis">1.2.6 Reports DB</a>
<li><a href="#Synopsis">1.2.7 Testrun DB</a>
<li><a href="#Synopsis">1.2.8 Testrun</a>
<li><a href="#Synopsis">1.2.9 Preconditions</a>
<li><a href="#Synopsis">1.2.10 Report</a>
<li><a href="#Synopsis">1.2.11 Test Anything Protocol (TAP)</a>
<li><a href="#Synopsis">1.2.12 TAP archives</a>
</li></ul>
</li></ul>
<li><a name="toc_Technical-Infrastructure" href="#Technical-Infrastructure">2 Technical Infrastructure</a>
<ul>
<li><a href="#Technical-Infrastructure">2.1 Adding a new host into automation</a>
<ul>
<li><a href="#Technical-Infrastructure">2.1.1 Make machine remote hard resetable</a>
<li><a href="#Technical-Infrastructure">2.1.2 Make machine PXE boot aware</a>
<li><a href="#Technical-Infrastructure">2.1.3 Configure TFTP on central MCP machine</a>
<li><a href="#Technical-Infrastructure">2.1.4 Make the hosts known in the TestrunDB</a>
<li><a href="#Technical-Infrastructure">2.1.5 Optionally: enable &lsquo;<samp><span class="samp">temare</span></samp>&rsquo; to generate tests for this host</a>
</li></ul>
</li></ul>
<li><a name="toc_Test-Protocol" href="#Test-Protocol">3 Test Protocol</a>
<ul>
<li><a href="#Test-Protocol">3.1 Test Anything Protocol (TAP)</a>
<li><a href="#Test-Protocol">3.2 Tutorial</a>
<ul>
<li><a href="#Test-Protocol">3.2.1 Just plan and success</a>
<li><a href="#Test-Protocol">3.2.2 Succession numbers</a>
<li><a href="#Test-Protocol">3.2.3 Test descriptions</a>
<li><a href="#Test-Protocol">3.2.4 Mark tests as TODO</a>
<li><a href="#Test-Protocol">3.2.5 Comment TODO tests with reason</a>
<li><a href="#Test-Protocol">3.2.6 Mark tests as SKIP (with reason)</a>
<li><a href="#Test-Protocol">3.2.7 Diagnostics</a>
<li><a href="#Test-Protocol">3.2.8 YAML Diagnostics</a>
<li><a href="#Test-Protocol">3.2.9 Meta information headers for reports</a>
<li><a href="#Test-Protocol">3.2.10 Report sections</a>
<li><a href="#Test-Protocol">3.2.11 Meta information headers for report sections</a>
<li><a href="#Test-Protocol">3.2.12 Meta information structure summary</a>
<li><a href="#Test-Protocol">3.2.13 Explicit section markers with lazy plans</a>
<li><a href="#Test-Protocol">3.2.14 Developing with TAP</a>
<li><a href="#Test-Protocol">3.2.15 TAP tips</a>
</li></ul>
<li><a href="#Test-Protocol">3.3 Particular use-cases</a>
<ul>
<li><a href="#Test-Protocol">3.3.1 Report Groups</a>
<ul>
<li><a href="#Test-Protocol">3.3.1.1 Report grouping by same testrun</a>
<li><a href="#Test-Protocol">3.3.1.2 Report grouping by arbitrary idenitifier</a>
</li></ul>
</li></ul>
<li><a href="#Test-Protocol">3.4 TAP Archives</a>
<li><a href="#Test-Protocol">3.5 Reporting TAP to the reports receiver</a>
<ul>
<li><a href="#Test-Protocol">3.5.1 Submitting raw TAP</a>
<li><a href="#Test-Protocol">3.5.2 Submitting TAP Archives</a>
</li></ul>
</li></ul>
<li><a name="toc_Test-Suite-Wrappers" href="#Test-Suite-Wrappers">4 Test Suite Wrappers</a>
<ul>
<li><a href="#Test-Suite-Wrappers">4.1 Available test suite wrappers</a>
<ul>
<li><a href="#Test-Suite-Wrappers">4.1.1 LMbench</a>
<li><a href="#Test-Suite-Wrappers">4.1.2 kernbench</a>
<li><a href="#Test-Suite-Wrappers">4.1.3 CTCS</a>
<li><a href="#Test-Suite-Wrappers">4.1.4 LTP</a>
<li><a href="#Test-Suite-Wrappers">4.1.5 dom0-meta</a>
<li><a href="#Test-Suite-Wrappers">4.1.6 Many more</a>
</li></ul>
<li><a href="#Test-Suite-Wrappers">4.2 Environment variables</a>
</li></ul>
<li><a name="toc_Preconditions" href="#Preconditions">5 Preconditions</a>
<ul>
<li><a href="#Preconditions">5.1 SYNOPSIS</a>
<li><a href="#Preconditions">5.2 Layers of preconditions</a>
<ul>
<li><a href="#Preconditions">5.2.1 Normal preconditions</a>
<li><a href="#Preconditions">5.2.2 Macro preconditions</a>
</li></ul>
<li><a href="#Preconditions">5.3 Precondition repository</a>
<li><a href="#Preconditions">5.4 Overview: Precondition Types</a>
<ul>
<li><a href="#Preconditions">5.4.1 Overview: Action precondition types</a>
<li><a href="#Preconditions">5.4.2 Overview: Highlevel precondition types</a>
</li></ul>
<li><a href="#Preconditions">5.5 Details: Precondition Types</a>
<ul>
<li><a href="#Preconditions">5.5.1 installer_stop</a>
<li><a href="#Preconditions">5.5.2 grub</a>
<li><a href="#Preconditions">5.5.3 package</a>
<li><a href="#Preconditions">5.5.4 copyfile</a>
<li><a href="#Preconditions">5.5.5 fstab</a>
<li><a href="#Preconditions">5.5.6 image</a>
<li><a href="#Preconditions">5.5.7 repository</a>
<li><a href="#Preconditions">5.5.8 type: prc</a>
<li><a href="#Preconditions">5.5.9 type: exec</a>
<li><a href="#Preconditions">5.5.10 type: hint</a>
<li><a href="#Preconditions">5.5.11 quote subtleties</a>
<li><a href="#Preconditions">5.5.12 type: reboot</a>
<li><a href="#Preconditions">5.5.13 type: autoinstall</a>
<li><a href="#Preconditions">5.5.14 type: testprogram</a>
<li><a href="#Preconditions">5.5.15 type: virt</a>
<li><a href="#Preconditions">5.5.16 General precondition keys &ldquo;mountfile&rdquo;</a>
</li></ul>
<li><a href="#Macro-Preconditions">5.6 Macro Preconditions</a>
<ul>
<li><a href="#A-real-live-example-_002d-kernel-boot-test">5.6.1 A real live example - kernel boot test</a>
</li></ul>
<li><a href="#A-real-live-example-_002d-kernel-boot-test">5.7 Precondition Producers</a>
<ul>
<li><a href="#A-real-live-example-_002d-kernel-boot-test">5.7.1 Lazy precondition</a>
<li><a href="#A-real-live-example-_002d-kernel-boot-test">5.7.2 Producer API</a>
<li><a href="#A-real-live-example-_002d-kernel-boot-test">5.7.3 Existing producers</a>
<li><a href="#A-real-live-example-_002d-kernel-boot-test">5.7.4 Example: &ldquo;Kernel&rdquo; precondition producer</a>
<ul>
<li><a href="#A-real-live-example-_002d-kernel-boot-test">5.7.4.1 Lazy precondition</a>
<li><a href="#A-real-live-example-_002d-kernel-boot-test">5.7.4.2 Resulting preconditions</a>
</li></ul>
</li></ul>
</li></ul>
<li><a name="toc_Command-line-interface" href="#Command-line-interface">6 Command line interface</a>
<ul>
<li><a href="#SYNOPSIS">6.1 SYNOPSIS</a>
<li><a href="#Scheduling">6.2 Scheduling</a>
<ul>
<li><a href="#Create-new-queue-and-new-host-and-bind-both-together">6.2.1 Create new queue and new host and bind both together</a>
<li><a href="#Change-queue-priority">6.2.2 Change queue priority</a>
<li><a href="#requested-features">6.2.3 requested features</a>
<li><a href="#Cancel-current-testrun-on-host">6.2.4 Cancel current testrun on host</a>
</li></ul>
</li></ul>
<li><a name="toc_Web-User-Interface" href="#Web-User-Interface">7 Web User Interface</a>
<ul>
<li><a href="#Web-User-Interface">7.1 Usage</a>
<li><a href="#Web-User-Interface">7.2 Understanding Artemis Details</a>
<ul>
<li><a href="#Web-User-Interface">7.2.1 Part 1 Overview</a>
<li><a href="#Web-User-Interface">7.2.2 Part 2 Details</a>
<li><a href="#Web-User-Interface">7.2.3 Part 3 Testrun</a>
</li></ul>
</li></ul>
<li><a name="toc_Reports-API" href="#Reports-API">8 Reports API</a>
<ul>
<li><a href="#Overview">8.1 Overview</a>
<li><a href="#Raw-API-Commands">8.2 Raw API Commands</a>
<ul>
<li><a href="#upload-aka_002e-attach-a-file-to-a-report">8.2.1 upload aka. attach a file to a report</a>
<ul>
<li><a href="#upload-_002d-Synopsis">8.2.1.1 upload - Synopsis</a>
<li><a href="#Parameters">8.2.1.2 Parameters</a>
<li><a href="#upload-Payload">8.2.1.3 upload Payload</a>
<li><a href="#upload-Example-usage">8.2.1.4 upload Example usage</a>
</li></ul>
<li><a href="#download-_002d-download-a-file-which-is-attached-to-a-report">8.2.2 download - download a file which is attached to a report</a>
<ul>
<li><a href="#download-Synopsis">8.2.2.1 download Synopsis</a>
<li><a href="#download-Parameters">8.2.2.2 download Parameters</a>
<li><a href="#download-Example-usage">8.2.2.3 download Example usage</a>
</li></ul>
<li><a href="#mason-_002d-Render-templates-with-embedded-query-language">8.2.3 mason - Render templates with embedded query language</a>
<ul>
<li><a href="#mason-Synopsis">8.2.3.1 mason Synopsis</a>
<li><a href="#mason-Parameters">8.2.3.2 mason Parameters</a>
<li><a href="#Payload">8.2.3.3 mason Payload</a>
<li><a href="#Example-usage">8.2.3.4 Example usage</a>
</li></ul>
</li></ul>
<li><a href="#Query-language-DPath">8.3 Query language DPath</a>
<ul>
<li><a href="#Reports-Filter-_0028SQL_002dAbstract_0029">8.3.1 Reports Filter (SQL-Abstract)</a>
<ul>
<li><a href="#SQL_002dAbstract-expressions">8.3.1.1 SQL::Abstract expressions</a>
<li><a href="#The-data-structure">8.3.1.2 The data structure</a>
</li></ul>
<li><a href="#Data-Filter">8.3.2 Data Filter</a>
<ul>
<li><a href="#Data_002dDPath-expressions">8.3.2.1 Data-DPath expressions</a>
</li></ul>
<li><a href="#Optimizations">8.3.3 Optimizations</a>
</li></ul>
<li><a href="#Client-Utility-artemis_002dapi">8.4 Client Utility artemis-api</a>
<ul>
<li><a href="#help">8.4.1 help</a>
<li><a href="#upload">8.4.2 upload</a>
<li><a href="#mason">8.4.3 mason</a>
</li></ul>
</li></ul>
<li><a name="toc_Complete-Use-Cases" href="#Complete-Use-Cases">9 Complete Use Cases</a>
<ul>
<li><a href="#Complete-Use-Cases">9.1 Automatic Xen testing</a>
<ul>
<li><a href="#Complete-Use-Cases">9.1.1 Paths</a>
<li><a href="#Complete-Use-Cases">9.1.2 Choose an image for Dom0 and images for each guest</a>
<li><a href="#Complete-Use-Cases">9.1.3 PRC configuration</a>
<ul>
<li><a href="#Complete-Use-Cases">9.1.3.1 Guest Start Configuration</a>
<li><a href="#Complete-Use-Cases">9.1.3.2 Testsuite Configuration</a>
</li></ul>
<li><a href="#Complete-Use-Cases">9.1.4 Preconditions</a>
<li><a href="#Complete-Use-Cases">9.1.5 Resulting YAML config</a>
<li><a href="#Complete-Use-Cases">9.1.6 Grub</a>
<li><a href="#Complete-Use-Cases">9.1.7 Order Testrun</a>
</li></ul>
</li></ul>
</li></ul>
</div>

<div class="node">
<a name="Synopsis"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Technical-Infrastructure">Technical Infrastructure</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Synopsis</h2>

<h3 class="section">1.1 ARTEMIS infrastructure</h3>

<p>ARTEMIS is an infrastructure.

<p>It consists of applications, tools and protocols for testing software
and evaluating the results. One main focus is on testing Operating
Systems in virtualization environments.

<p>There are 3 important layers:

     <ul>
<li><strong>Reports Framework</strong>

     <li><strong>Test Suites</strong>

     <li><strong>Automation System</strong>

</ul>

<p>The layers can work completely autonomously, though can also be
connected together and are targeted to be stacked in this order:

     <ul>
<li>The <strong>Report Framework</strong> is for receiving and evaluating
test reports sent by any source. The only requirement is that the
result reports are using TAP, the Test Anything Protocol.

     <li>The <strong>Test Suites</strong> are either directed test suites or
wrappers around existing test projects doing conversion of their
results into TAP. These are the TAP producers that create reports and
send them to the Reports Framework.

     <li>The <strong>Automation System</strong> is taking care of setting up
machines, installing dependencies and test suites and running the
latter. It can set up virtualized environments.

</ul>

<p>To fully exploit the system you need to learn:

     <ul>
<li><strong>Connect and prepare a new machine into the infrastructure</strong>

     <li><strong>Write tests using the Test Anything Protocol (TAP)</strong>

     <li><strong>Write preconditions to describe automation tasks</strong>

     <li><strong>Review results via Web interface</strong>

     <li><strong>Evaluate results via Report Query interface</strong>

</ul>

<h3 class="section">1.2 Vocabulary</h3>

<h4 class="subsection">1.2.1 Master Control Program (MCP)</h4>

<p>There is a central server controlling the automation by running the
<strong>Master Control Program</strong>, aka. <strong>MCP</strong>. Usually it also
centralizes several other services: it is the TFTP server for network
booting, runs the daemons of the reports framework (reports receiver,
remote api) and the web application, including the mysql databases,
and also serves the file repository via NFS.

<h4 class="subsection">1.2.2 Program Run Control (PRC)</h4>

<p>When machines run automated tests, these test program runs are
controlled by a <strong>Program Run Control</strong>, aka. <strong>PRC</strong>. In
virtualization scenarios, each host and guest has its own PRC,
numbered PRC0 (for the host), PRC1 (1st guest), PRC2 (2nd guest), etc.

<h4 class="subsection">1.2.3 Reports Receiver</h4>

<p>The <strong>Reports Receiver</strong> means the daemons that accept
reports. We often run them on the same machine as the MCP and the Web
framework, but that's not neccessary.

<h4 class="subsection">1.2.4 Reports API</h4>

<p>Similar to the reports receiver is the <strong>Reports API</strong> which is
the daemon for all more complex interfaces, like uploading files,
downloading files, querying the reports. Similar to reports API we
often run them on the same machine as the MCP and the Web application,
but that's not neccessary.

<h4 class="subsection">1.2.5 Web User Interface</h4>

<p>The <strong>Web User Interface</strong> is an independent web
application. Similar to the reports receiver and the reports API it
can run anywhere, either standalone or in Apache, via mod_perl, FCGI,
etc.. The only common thing for all those central applications (MCP,
reports receiver, reports api, web application) is the config to use
the same databases.

<h4 class="subsection">1.2.6 Reports DB</h4>

<p>The <strong>Reports DB</strong> contains all data that are reported. It's the
base for the reports receiver, the reports API, the web application.

<h4 class="subsection">1.2.7 Testrun DB</h4>

<p>The <strong>Testrun DB</strong> is the DB for the automation layer. It
contains hosts, testrun specifications and scheduling information.

<h4 class="subsection">1.2.8 Testrun</h4>

<p>A <strong>Testrun</strong> is a request to the automation layer to set up a
host machine and run a workload on it. It consists of
&ldquo;preconditions&rdquo; and scheduling information (host name, wanted host
features, scheduling queue).

<h4 class="subsection">1.2.9 Preconditions</h4>

<p><strong>Preconditions</strong> are specifications that describe how to set up
a host. They are the essential part of a testrun.

<h4 class="subsection">1.2.10 Report</h4>

<p>A <strong>Report</strong> is the reported result of any workload, regardless
of how it was produced (automatically, by a tes suite, manually via
echo and netcat). Its only requirement is to be formatted in TAP (the
Test Anything Protocol), or as TAP archive.

<h4 class="subsection">1.2.11 Test Anything Protocol (TAP)</h4>

<p>The <strong>Test Anything Protocol</strong> aka. <strong>TAP</strong> is the syntax to
describe test results.

<h4 class="subsection">1.2.12 TAP archives</h4>

<p>A <strong>TAP archive</strong> is a .tar.gz file that contains files of
TAP. It's the result of a test suite that can consist of many parts
compressed into a single file.

<div class="node">
<a name="Technical-Infrastructure"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Test-Protocol">Test Protocol</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Synopsis">Synopsis</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Technical Infrastructure</h2>

<p>See also the &ldquo;Getting Started Guide&rdquo; for more complete step-by-step
instructions how to install the infrastructure from scratch up to a
first example test run.

<h3 class="section">2.1 Adding a new host into automation</h3>

<p>This chapter describes what you need to do in order to get a new
machine into the Artemis test scheduling rotation.

<h4 class="subsection">2.1.1 Make machine remote hard resetable</h4>

<p>Connect the machine physically to some facility to programmatically
switch it completely off.

<p>This can be the Reset cable wires connected to a dedicated reset box
which can be programmed usually with an external tool. It can also be
a TCP/IP controllable Power Control.

<p>As an example Artemis comes with a plugin for the &ldquo;Infratec PM211
MIP&rdquo; ethernet controllable multi socket outlet. To use it write this
in the configuration file:

<pre class="verbatim">reset_plugin: PM211MIP
reset_plugin_options:
  ip: 192.168.1.39
  user: admin
  passwd: secret
  outletnr:
    johnconnor: 1
    sarahconnor: 2
</pre>

<p>This configures to use the PM211MIP plugin for reset and gives it the
configuration that the host &ldquo;johnconnor&rdquo; is connected on port 0 and
the host &ldquo;sarahconnor&rdquo; on port 1, together with IP address, username
and password of the multi-socket outlet.

<p>If you have other hardware then write your own reset plugin
<code>FooBar</code> in a Perl module
<code>Artemis::MCP::Net::Reset::FooBar</code>. Look into the code of
<code>Artemis::MCP::Net::Reset::PM211MIP</code> to get inspiration.

<h4 class="subsection">2.1.2 Make machine PXE boot aware</h4>

     <ul>
<li>Set booting order in BIOS to network first

     <li>Configure DHCP for each connected machine

     <p>The following example configures two hosts &lsquo;<samp><span class="samp">sarahconnor</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">johnconnor</span></samp>&rsquo; to use the respective files
&lsquo;<samp><span class="samp">/tftpboot/sarahconnor.lst</span></samp>&rsquo; and &lsquo;<samp><span class="samp">/tftpboot/johnconnor.lst</span></samp>&rsquo;
as grub config.

     <pre class="verbatim">     # example dhcp config with invalid ethernet addresses
     subnet 192.168.1.0 netmask 255.255.255.0 {
     group
     {
      filename '/tftpboot/pxegrub';
      # offer the host the here given name as host name
      option host-name = host-decl-name;
      option dhcp-parameter-request-list = concat(option dhcp-parameter-request-list,96);
      host sarahconnor
      {
        hardware ethernet 00:09:11:11:11:11;
        fixed-address 192.168.1.2;
        option configfile "/tftpboot/sarahconnor.lst";
      }
      host johnconnor
      {
       hardware ethernet 00:09:22:22:22:22;
       fixed-address 192.168.1.3;
       option configfile "/tftpboot/johnconnor.lst";
      }
     }
</pre>

     <p>These grub config files are later dynamically overwritten for each
boot by your application server's &ldquo;Master Control Program&rdquo; (MCP).

     <p>The example above assumes the DHCP also running on the central Master
Control Program (MCP) server. To use a DHCP server running on another
host configure it with some grub/tftp redirection chains to in the end
lead to the same files &lsquo;<samp><span class="samp">/tftpboot/sarahconnor.lst</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">/tftpboot/johnconnor.lst</span></samp>&rsquo; loaded from the MCP server.

     <li>Force DHCP server to reread its configuration

     <pre class="verbatim">      $ kill -HUP $pid_of_dhcpd
</pre>

</ul>

<h4 class="subsection">2.1.3 Configure TFTP on central MCP machine</h4>

<p>The MCP server is also acting as a TFTP server, so it has to be
configured as such:

     <ul>
<li>Install a TFTP server

     <pre class="verbatim">      $ sudo apt-get install inetutils-inetd
      $ sudo apt-get install atftpd
      $ sudo chmod 777 /var/lib/tftpboot/
      $ sudo ln -s /var/lib/tftpboot /tftpboot
</pre>

     <li>Create symlinks to point TFTP dir into ARTEMIS working dir

     <p>The TFTP daemon only serves files from &lsquo;<samp><span class="samp">/tftpboot</span></samp>&rsquo;, as seen above
in the DHCP config. To supply files from the Artemis working dir make
the &lsquo;<samp><span class="samp">/tftpboot</span></samp>&rsquo; a symlink to the Artemis working dir.

     <pre class="verbatim">      $ ln -s /data/artemis/live/configs/tftpboot /tftpboot
</pre>

     <p>When Artemis creates tftp files it works with absolute path
names. Because the TFTP daemon interprets all absolute pathnames
relative to its root dir we supply a &lsquo;<samp><span class="samp">tftpboot</span></samp>&rsquo; symlink inside
the tftp root (which is also our Artemis working dir), so we can use
the same absolute path name in both contexts (Artemis and TFTP):

     <pre class="verbatim">      $ ln -s /data/artemis/live/configs/tftpboot \
              /data/artemis/live/configs/tftpboot/tftpboot
</pre>

</ul>

<h4 class="subsection">2.1.4 Make the hosts known in the TestrunDB</h4>

<pre class="verbatim"> $ artemis-testrun newhost --name=sarahconnor --active=1
 $ artemis-testrun newhost --name=johnconnor  --active=1
</pre>

<p>This makes the hosts generally available (active) for scheduling
testruns by machine name. For scheduling hosts by more detailed
machine features (cpu, memory, family, etc.)  you need to add
according key/value pairs in the &lsquo;<samp><span class="samp">HostFeature</span></samp>&rsquo; table.

<h4 class="subsection">2.1.5 Optionally: enable &lsquo;<samp><span class="samp">temare</span></samp>&rsquo; to generate tests for this host</h4>

<p>&lsquo;<samp><span class="samp">Temare</span></samp>&rsquo; is an utility that generates preconditions according to
a test matrix of host/guest virtualization scenarios (but not yet
shipped publicly).

<p>For generating preconditions for a host, you can register the host in
&lsquo;<samp><span class="samp">temare</span></samp>&rsquo;.

<p>If you want tests scheduled for the new machine then follow these
steps:

     <ul>
<li>Login as root on MCP server

     <li>Set the <code>PYTHONPATH</code> to include the <em>temare</em> src directory

     <pre class="verbatim">     export PYTHONPATH=$PYTHONPATH:/opt/artemis/python/temare/src
</pre>

     <li>Add the host to temare hostlist

     <pre class="verbatim">      $ /opt/artemis/python/temare/temare hostadd $hostname \
                                                  $memory \
                                                  $cores \
                                                  $bitness
</pre>

</ul>

<p><a name="index-Index-entry-for-First-Chapter-1"></a>

<div class="node">
<a name="Test-Protocol"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Test-Suite-Wrappers">Test Suite Wrappers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Technical-Infrastructure">Technical Infrastructure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Test Protocol</h2>

<p>In order to write test suites you need to understand the output
protocol, which is &lsquo;<samp><span class="samp">TAP</span></samp>&rsquo;, the &lsquo;<samp><span class="samp">Test Anything Protocol</span></samp>&rsquo;.

<p>The protocol is trivially to produce, you can do it with simple Shell
&lsquo;<samp><span class="samp">echo</span></samp>&rsquo;s or you can use TAP emitting toolchains, like practically
all &lsquo;<samp><span class="samp">Test::*</span></samp>&rsquo; modules from the Perl world.

<p>This chapter explains the protocol and the Artemis specific
extensions, which are usually headers that can be transported inside
TAP comments.

<h3 class="section">3.1 Test Anything Protocol (TAP)</h3>

<h3 class="section">3.2 Tutorial</h3>

<h4 class="subsection">3.2.1 Just plan and success</h4>

<p><strong>Example:</strong>

<pre class="verbatim"> 1..3
 ok
 ok
 not ok
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>3 single tests planned
<li>the two first went good
<li>the last went wrong
</ul>

<h4 class="subsection">3.2.2 Succession numbers</h4>

<p><strong>Example:</strong>

<pre class="verbatim"> 1..3
 ok 1
 ok 2
 not ok 3
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>Missing test lines (eg. due to internal bummers) can be detected. 
</ul>

<p><strong>Example with missing test:</strong>

<pre class="verbatim"> 1..3
 ok 1
 not ok 3
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>Parsing will later say &ldquo; test 2 expected but got 3&rdquo;
</ul>

<h4 class="subsection">3.2.3 Test descriptions</h4>

<p><strong>Example:</strong>

<pre class="verbatim"> 1..3
 ok 1 - input file opened
 ok 2 - file content
 not ok 3 - last line
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>Readability. 
</ul>

<h4 class="subsection">3.2.4 Mark tests as TODO</h4>

<p><strong>Example:</strong>

<pre class="verbatim"> 1..3
 ok 1 - input file opened
 ok 2 - file content
 not ok 3 - last line # TODO
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>mark not yet working tests as "TODO"
<li>allows test-first development
<li>"ok" TODOs are recognized later
 ("unexpectedly succeeded")
<li>We also use it to ignore known issues with still being able to find
them later. 
</ul>

<h4 class="subsection">3.2.5 Comment TODO tests with reason</h4>

<p><strong>Example:</strong>

<pre class="verbatim"> 1..3
 ok 1 - input file opened
 ok 2 - file content
 not ok 3 - last line # TODO just specced
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>comment the TODO reason
</ul>

<h4 class="subsection">3.2.6 Mark tests as SKIP (with reason)</h4>

<p><strong>Example:</strong>

<pre class="verbatim"> 1..3
 ok 1 - input file opened
 ok 2 - file content
 ok 3 - last line # SKIP missing prerequisites
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>mark tests when not really run (note it's set to &ldquo;ok&rdquo; anyway)
<li>keeps succession numbers in sync
</ul>

<h4 class="subsection">3.2.7 Diagnostics</h4>

<p><strong>Example:</strong>

<pre class="verbatim"> 1..3
 ok 1 - input file opened
 ok 2 - file content
 not ok 3 - last line # TODO just specced
 # Failed test 'last line'
 # at t/data_dpath.t line 410.
 # got: 'foo'
 # expected: 'bar'
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>Unstructured details
</ul>

<h4 class="subsection">3.2.8 YAML Diagnostics</h4>

<p><strong>Example:</strong>

<pre class="verbatim"> 1..3
 ok 1 - input file opened
 ok 2 - file content
 not ok 3 - last line # TODO just specced
   ---
   message: Failed test 'last line' at t/data_dpath.t line 410.
   severity: fail
   data:
     got: 'foo'
     expect: 'bar'
   ...
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>Structured details
<li>allows parsable diagnostics
<li>we use that to track values inside TAP
<li>have a leading test line with number+description
<li>track complete data structures according to it
          <ul>
<li>e.g., benchmark results
</ul>
     </ul>

<h4 class="subsection">3.2.9 Meta information headers for reports</h4>

<p>TAP allows comment lines, starting with &lsquo;<samp><span class="samp">#</span></samp>&rsquo;. We allow meta
information transported inside those comment lines when declared with
Artemis specific headers.

<p><strong>Example:</strong>

<pre class="verbatim"> 1..3
 # Artemis-Suite-Name: Foo-Bar
 # Artemis-Suite-Version: 2.010013
 ok 1 - input file opened
 ok 2 - file content
 not ok 3 - last line # TODO just specced
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>we use diagnostics lines (&ldquo;hot comments&rdquo;)
<li>semantics only to our TAP applications
</ul>

<p>These are the headers that apply to the whole report:

<pre class="verbatim"> # Artemis-suite-name:                 -- suite name
 # Artemis-suite-version:              -- suite version
 # Artemis-machine-name:               -- machine/host name
 # Artemis-machine-description:        -- more details to machine
 # Artemis-reportername:               -- user name of the reporter
 # Artemis-starttime-test-program:     -- start time for complete test
                                          (including guests)
 # Artemis-endtime-test-program:       -- end time for complete test
                                          (including guests)
 # Artemis-reportgroup-testrun:        -- associate this report with other 
                                          reports of same testrun_id
 # Artemis-reportgroup-arbitrary:      -- associate this report with other 
                                          reports of same arbitrary id
                                          (can be any string, but should be
                                          unique between all groups of the db,
                                          eg., an md5-hash of common 
                                          characteristics of all test of one 
                                          group)

</pre>

<p>There are more headers that apply to single sections of a report.

<h4 class="subsection">3.2.10 Report sections</h4>

<p>Standard TAP contains of exactly one block with one plan (eg., 1..5)
and some TAP lines. In Artemis you can concatenate several such blocks
at once. They are interpreted like different files, and are named
<em>sections</em> in Artemis jargon.

<p>The delimiter between such sections is the plan line. This requires
the plan to come first for each section. See chapters &ldquo;Explicit
section markers with lazy plans&rdquo; and &ldquo;TAP archives&rdquo; below for
explicitely providing other TAP section delimiters.

<p>Please remember: <strong>Concatenating several sections into one big
block of TAP is an ARTEMIS extension. To interact with other TAP
toolchains you should try to use &ldquo;TAP archives&rdquo; when submitting
sections into ARTEMIS.</strong>

<p><strong>Example:</strong>

<pre class="verbatim"> 1..2
 # Artemis-section: arithmetics
 ok 1 add
 ok 2 multiply
 1..1
 # Artemis-section: string handling
 ok 1 concat
 1..3
 # Artemis-section: benchmarks
 ok 1
 ok 2
 ok 3
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>we recognize &ldquo;sections&rdquo;, each with its own plan
<li>allows structuring of results,
<li>better readability later in web interface
</ul>

<h4 class="subsection">3.2.11 Meta information headers for report sections</h4>

<p>These are the headers that apply to single sections:

<pre class="verbatim">
 # Artemis-explicit-section-start:   -- explicitely start a section now
                                        instead of autorecognition
 # Artemis-ram:                      -- memory
 # Artemis-cpuinfo:                  -- what CPU
 # Artemis-uname:                    -- kernel information
 # Artemis-osname:                   -- OS information
 # Artemis-bios:                     -- BIOS information
 # Artemis-flags:                    -- flags, usually linux kernel
 # Artemis-changeset:                -- exact changeset of the currently 
                                        tested software or kernel
 # Artemis-description:              -- more description of the currently
                                        tested software or kernel, 
                                        e.g., if changeset is not enough
 # Artemis-uptime:                   -- uptime, maybe the test run time
 # Artemis-language-description:     -- for Software tests, 
                                        like "Perl 5.10", "Python 2.5"
 # Artemis-reportcomment:            -- Freestyle comment

 # Artemis-xen-version:              -- Xen version
 # Artemis-xen-changeset:            -- particular Xen changeset
 # Artemis-xen-dom0-kernel:          -- the kernel version of the dom0
 # Artemis-xen-base-os-description:  -- more verbose OS information
 # Artemis-xen-guest-description:    -- description of a guest
 # Artemis-xen-guest-test:           -- the started test program
 # Artemis-xen-guest-start:          -- start time of test
 # Artemis-xen-guest-flags:          -- flags used for starting the guest

 # Artemis-kvm-module-version:       -- version of KVM kernel module
 # Artemis-kvm-userspace-version:    -- version of KVM userland tools
 # Artemis-kvm-kernel:               -- version of kernel
 # Artemis-kvm-base-os-description:  -- more verbose OS information
 # Artemis-kvm-guest-description:    -- description of a guest
 # Artemis-kvm-guest-test:           -- the started test program
 # Artemis-kvm-guest-start:          -- start time of test
 # Artemis-kvm-guest-flags:          -- flags used for starting the guest

 # Artemis-simnow-version:           -- version of simnow
 # Artemis-simnow-svn-version:       -- svn commit id of simnow
 # Artemis-simnow-svn-repository:    -- used svn repository
 # Artemis-simnow-device-interface-version: -- internal simnow device 
                                               interface version
 # Artemis-simnow-bsd-file:          -- used BSD file (machine model)
 # Artemis-simnow-image-file:        -- used OS image botted in simnow
                                        (usually similar to
                                        Artemis-osname or
                                        Artemis-xen-base-os-description or
                                        Artemis-kvm-base-os-description)

</pre>

<h4 class="subsection">3.2.12 Meta information structure summary</h4>

<p>There are groups of reports (e.g. for virtualization scenarios),
optionally identified by a testrun ID or by an arbitrary ID. Every
report has an ID and a set of meta information. A report consists of
sections, which can each have section specific set of meta
information.

<p>The resulting meta information hierarchy looks like this.

     <ul>
<li>Reportgroup

     <pre class="verbatim">     - testrun reportgroup ID
     - arbitrary reportgroup ID
</pre>

          <ul>
<li>Report

          <pre class="verbatim">          - report ID
          - Artemis-suite-name
          - Artemis-suite-version
          - Artemis-machine-name
          - Artemis-machine-description
          - Artemis-reportername
          - Artemis-starttime-test-program
          - Artemis-endtime-test-program
          - Artemis-reportgroup-testrun
          - Artemis-reportgroup-arbitrary
     </pre>

               <ul>
<li>Section

               <pre class="verbatim">               - Artemis-explicit-section-start
               - Artemis-ram
               - Artemis-cpuinfo
               - Artemis-uname
               - Artemis-osname
               - Artemis-bios
               - Artemis-flags
               - Artemis-changeset
               - Artemis-description
               - Artemis-uptime
               - Artemis-language-description
               - Artemis-reportcomment
               - Artemis-xen-version
               - Artemis-xen-changeset
               - Artemis-xen-dom0-kernel
               - Artemis-xen-base-os-description
               - Artemis-xen-guest-description
               - Artemis-xen-guest-test
               - Artemis-xen-guest-start
               - Artemis-xen-guest-flags
               - Artemis-kvm-module-version
               - Artemis-kvm-userspace-version
               - Artemis-kvm-kernel
               - Artemis-kvm-base-os-description
               - Artemis-kvm-guest-description
               - Artemis-kvm-guest-test
               - Artemis-kvm-guest-start
               - Artemis-kvm-guest-flags
               - Artemis-simnow-version
               - Artemis-simnow-svn-version
               - Artemis-simnow-svn-repository
               - Artemis-simnow-device-interface-version
               - Artemis-simnow-bsd-file
               - Artemis-simnow-image-file
          </pre>

          </ul>

     </ul>

</ul>

<h4 class="subsection">3.2.13 Explicit section markers with lazy plans</h4>

<p>In TAP it is allowed to print the plan (1..n) after the test lines (a
&ldquo;lazy plan&rdquo;).  In our ARTEMIS environment with concatenated sections
this would break the default section splitting which uses the plan to
recognize a section start.

<p>If you want to use such a &ldquo;lazy plan&rdquo; in your report you can print
an ARTEMIS header <code>Artemis-explicit-section-start</code> to explictely
start a section. Everything until the next header
<code>Artemis-explicit-section-start</code> is building one section. This
also means that if you used this header <strong>once</strong> in a report you
need to use it for <strong>all</strong> sections in this report.

<p>The <code>Artemis-explicit-section-start</code> typically ignores its value
but it is designed anyway to allow any garbage after the value that
can help you visually structure your reports because explicit sections
with &ldquo;lazy plans&rdquo; make a report hard to read.

<p><strong>Example:</strong>

<pre class="verbatim"> # Artemis-explicit-section-start: 1 ------ arithmetics -------
 # Artemis-section: arithmetics
 ok 1 add
 ok 2 multiply
 1..2
 # Artemis-explicit-section-start: 1 ------ string handling -------
 # Artemis-section: string handling
 ok 1 concat
 1..1
 # Artemis-explicit-section-start: 1 ------ benchmarks -------
 # Artemis-section: benchmarks
 ok 1
 ok 2
 ok 3
 1..3
</pre>

<p>Please note again: <strong>The sectioning in general and this
auxiliary header for marking sections is an ARTEMIS extension, not
standard TAP. An alternative way better than fiddling with this
sectioning is to produce TAP archives and submit them instead. See
chapter &ldquo;TAP Archives&rdquo;.</strong>

<h4 class="subsection">3.2.14 Developing with TAP</h4>

<p>TAP consuming is provided via the <code>Test::Harness</code>
aka. <code>TAP::Parser</code> Perl toolchain. The frontend utility to
execute TAP emitting tests and evaluate statistics is <code>prove</code>.

<pre class="verbatim"> $ prove t/*.t
 t/00-load.........ok
 t/boilerplate.....ok
 t/pod-coverage....ok
 All tests successful.
 Files=4, Tests=6, 0 wallclock secs
 ( 0.05 usr 0.00 sys + 0.28 cusr 0.05 csys = 0.38 CPU)
 Result: PASS
</pre>

<p><strong>Remarks:</strong>
     <ul>
<li>TAP::Parser
          <ul>
<li><code>prove</code> tool
<li>overall success and statistics
<li>allows &lsquo;<samp><span class="samp">formatters</span></samp>&rsquo;
<li>used to produce web reports
</ul>
     </ul>

<p>It helps to not rely on ARTEMIS extensions (like report sections) when
using the <code>prove</code> command.

<h4 class="subsection">3.2.15 TAP tips</h4>

     <ul>
<li>TAP is easy to produce but using it <strong>usefully</strong> can be a challenge. 
<li>Think &ldquo;ARTEMIS&rdquo; &ndash; l'Art `emis &ndash; &ldquo;The art to emit&rdquo;. 
<li>Use <strong>invariable</strong> test descriptions. 
<li>Put meta information in diagnostics lines, <strong>not</strong> into test descriptions. 
<li>Use the description after <code># TODO/SKIP</code>. 
<li>Cheat visible (or: don't cheat invisible). 
<li>Really use <code># TODO/SKIP</code>. 
</ul>

<p>These tips keep later TAP evaluation consistent.

<h3 class="section">3.3 Particular use-cases</h3>

<h4 class="subsection">3.3.1 Report Groups</h4>

<h5 class="subsubsection">3.3.1.1 Report grouping by same testrun</h5>

<p>If we have a Xen environment then there are many guests each running
some test suites but they don't know of each other.

<p>The only thing that combines them is a common testrun-id. If each
suite just reports this testrun-id as the group id, then the receiving
side can combine all those autonomously reporting suites back together
by that id.

<p>So simply each suite should output

<pre class="verbatim"> # Artemis-reportgroup-testrun: 1234
</pre>

<p>with 1234 being a testrun ID that is available via the environment
variable <code>$ARTEMIS_TESTRUN</code>. This variable is provided by the
automation layer.

<h5 class="subsubsection">3.3.1.2 Report grouping by arbitrary idenitifier</h5>

<p>If the grouping id is not a testrun id, e.g., because you have set up
a Xen environment without the ARTEMIS automation layer, then generate
one random value once in dom0 by yourself and use that same value
inside all guests with the following header:

     <ul>
<li>get the value:

     <pre class="verbatim">      ARTEMIS_REPORT_GROUP=`date|md5sum|awk '{print $1}'`
</pre>

     <li>use the value:

     <pre class="verbatim">      # Artemis-reportgroup-arbitrary: $ARTEMIS_REPORT_GROUP
</pre>

</ul>

<p>How that value gets from <em>dom0</em> into the guests is left as an
exercise, e.g. via preparing the init scripts in the guest images
before starting them. That's not the problem of the test suite
wrappers, they should only evaluate the environment variable
<code>ARTEMIS_REPORT_GROUP</code>.

<h3 class="section">3.4 TAP Archives</h3>

<p>Some TAP emitting toolchains allow the generation of .tar.gz files
containing TAP, so called <em>TAP archives</em>. E.g., via &lsquo;<samp><span class="samp">prove</span></samp>&rsquo;:

<pre class="verbatim"> $ prove -a /tmp/myresults.tgz t/
</pre>

<p>You can later submit such TAP archive files to the Artemis reports
receiver tha same way as you report raw TAP.

<h3 class="section">3.5 Reporting TAP to the reports receiver</h3>

<p>The Artemis reports receiver is a daemon that listens on a port and
slurps in everything between the open and close of a connection to
it. Therefore you can use &lsquo;<samp><span class="samp">netcat</span></samp>&rsquo; to report TAP.

<p>Remember that using &lsquo;<samp><span class="samp">netcat</span></samp>&rsquo; in turn can be a mess, the are
several flavours with different options which are also changing their
behaviour over time. So to be sure, you better do your own socket
communication with Perl or Python: open socket, print to socket, close
socket, done. We just keep with &lsquo;<samp><span class="samp">netcat</span></samp>&rsquo; for illustrating the
examples.

<h4 class="subsection">3.5.1 Submitting raw TAP</h4>

<p>Simply submit all TAP directly into the socket of the reports
receiver:

<pre class="verbatim"> $ ./my_tap_emitting_test_suite | netcat artemis_server 7357
</pre>

<h4 class="subsection">3.5.2 Submitting TAP Archives</h4>

<p>You submit the content of a .tar.gz file in the same way you submit
raw TAP, via the same API. The receiver recognizes the .tar.gz
contenttype by itself.

<pre class="verbatim"> $ prove -a /tmp/myresults.tgz t/
 $ cat /tmp/myresults.tgz | netcat artemis_server 7357
</pre>

<div class="node">
<a name="Test-Suite-Wrappers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Preconditions">Preconditions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Test-Protocol">Test Protocol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Test Suite Wrappers</h2>

<p>This section is about the test suites and wrappers around existing
suites. These wrappers are part of our overall test infrastructure.

<p>It's basically about the middle part in the following picture:

<div class="block-image"><img src="artemis_architecture_overview.png" alt="artemis_architecture_overview.png"></div>

<p>We have wrappers for existing test and benchmark suites.

<p>Wrappers just run the suites as a user would manually run them but
additionally extract results and produce TAP (Test Anything Protocol).

<p>We have some specialized, small test suites that complement the
general suites, e.g. for extracting meta information or parsing logs
for common problems.

<p>If the environment variables

<pre class="verbatim">ARTEMIS_REPORT_SERVER
ARTEMIS_REPORT_PORT
</pre>

<p>are set the wrappers report their results by piping their TAP output
there, else they print to STDOUT.

<h3 class="section">4.1 Available test suite wrappers</h3>

<h4 class="subsection">4.1.1 LMbench</h4>

     <dl>
<dt><b>artemis_testsuite_lmbench.sh</b><dd>
A wrapper around the benchmark suite <em>LMbench</em>.

     <p>See also <a href="http://www.bitmover.com/lmbench/">http://www.bitmover.com/lmbench/</a>.

</dl>

<h4 class="subsection">4.1.2 kernbench</h4>

     <dl>
<dt><b>artemis_testsuite_kernbench.sh</b><dd>
A wrapper around the benchmark suite <em>kernbench</em>.

     <p>See also <a href="http://freshmeat.net/projects/kernbench/">http://freshmeat.net/projects/kernbench/</a>.

</dl>

<h4 class="subsection">4.1.3 CTCS</h4>

     <dl>
<dt><b>artemis_testsuite_ctcs.sh</b><dd>
A wrapper around the <em>Cerberus Test Control System (CTCS)</em>.

     <p>See also <a href="http://sourceforge.net/projects/va-ctcs/">http://sourceforge.net/projects/va-ctcs/</a>.

</dl>

<h4 class="subsection">4.1.4 LTP</h4>

     <dl>
<dt><b>artemis_testsuite_ltp.sh</b><dd>
A wrapper around the <em>Linux Test Project (LTP)</em>.

     <p>See also <a href="http://ltp.sourceforge.net/">http://ltp.sourceforge.net/</a>.

</dl>

<h4 class="subsection">4.1.5 dom0-meta</h4>

     <dl>
<dt><b>artemis_testsuite_dom0_meta.sh</b><dd>
A suite that produces meta information about the <em>dom0</em>
environment.

</dl>

<h4 class="subsection">4.1.6 Many more</h4>

<p>This list is a bit deprecated. We have many more test suite wrappers
and directed functional test suites in the mean time but not yet
published.

<h3 class="section">4.2 Environment variables</h3>

<p>The ARTEMIS automation layer provides some environment variables that
the wrappers can use:

     <dl>
<dt><b>ARTEMIS_TESTRUN</b><dd>Currently active Testrun ID.

     <br><dt><b>ARTEMIS_SERVER</b><dd>The controlling automation Server that initiated this testrun.

     <br><dt><b>ARTEMIS_REPORT_SERVER</b><dd>The target server to which the tests should report their results in
TAP.

     <br><dt><b>ARTEMIS_REPORT_PORT</b><dd>The target port to which the tests should report their results in
TAP. Complements <code>ARTEMIS_REPORT_SERVER</code>.

     <br><dt><b>ARTEMIS_REPORT_API_PORT</b><dd>The port on which the more sophisticated Remote Reports API is
available. It's running on the same host as
<code>ARTEMIS_REPORT_SERVER</code>.

     <br><dt><b>ARTEMIS_TS_RUNTIME</b><dd>Maximum runtime after which the testprogram will not be restarted when
it runs in a loop. (This is a more passive variant than a timeout.)

     <br><dt><b>ARTEMIS_GUEST_NUMBER</b><dd>Virtualisation guests are ordered, this is the guest number or 0 if
not a guest.

     <br><dt><b>ARTEMIS_NTP_SERVER</b><dd>The server where to request NTP dates from.

</dl>

<p>These variables should be used in the TAP of the suite as
<em>Artemis</em> headers. Important use-case is "report groups", see next
chapter.

<div class="node">
<a name="Preconditions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Command-line-interface">Command line interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Test-Suite-Wrappers">Test Suite Wrappers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Preconditions</h2>

<p>The central thing that is needed before a test is run is a so called
<dfn>precondition</dfn>. Creating those preconditions is the main task
needed to do when using the automation framework.

<p>Most of the <em>preconditions</em> describe packages that need to be
installed. Other preconditions describe how subdirs should be copied
or scripts be executed.

<p>A <em>precondition</em> can depend on other preconditions, leading to a
tree of preconditions that will be installed from the leaves to the
top.

<h3 class="section">5.1 SYNOPSIS</h3>

     <ul>
<li>Create a (maybe temporary) file

     <li>Define conditions for a testrun: the <dfn>preconditions</dfn>

     <li>Put the precondition into the database, maybe referring to other preconditions

     <li>Create a testrun in the database, referring to the precondition

     <li>Wait until the testrun is executed and results are reported

</ul>

<h3 class="section">5.2 Layers of preconditions</h3>

<p>There are &ldquo;normal preconditions&rdquo; and &ldquo;macro preconditions&rdquo;.

<h4 class="subsection">5.2.1 Normal preconditions</h4>

<p>We store preconditions in the database and assign <em>testruns</em> to
them (also in the database).

<p>Usually the preconditions were developed in a (temporary) file and
then entered into the database with a tool. After that the temporary
file can be deleted. Note that such a precondition file can contain
multiple precondition as long as they are formated as valid YAML.

<p><em>Preconditions</em> can be kept in files to re-use them when creating
testruns but that's not needed for archiving purposes, only for
creation purposes.

<p>Please note: <strong>Normal preconditions are usually not what you
want.</strong> It's the low level mechanism. Its advantage is in reusing the
preconditions by referring to IDs and creating trees of
preconditions. This reuse is usually too complex. <strong>What you
typically want are Macro Preconditions</strong>.

<h4 class="subsection">5.2.2 Macro preconditions</h4>

<p>There is another mechanism on top of normal preconditions: <dfn>Macro
Preconditions</dfn>. These allow to bundle <strong>multiple</strong> preconditions
at once into a common use-case.

<p>A <em>macro precondition</em> is evaluated when the testrun is added via
the cmdline utils (or the web app, both use the same underlying
layer). The result are &ldquo;normal preconditions&rdquo; which are inserted
into the DB everytime together with the testrun, so there is no reuse
of preconditions and preconditions are always a list, no tree. Anyhow,
they are much easier to handle.

<p><em>Macro preconditions</em> are template files which should be archived
in the precondition repository, as only the finally resulting
preconditions are stored in the database.

<h3 class="section">5.3 Precondition repository</h3>

<p>Macro preconditions can be stored in

<pre class="verbatim">/data/artemis/live/repository/macropreconditions/
</pre>

<h3 class="section">5.4 Overview: Precondition Types</h3>

<p>There are two variants of preconditions: <em>Action preconditions</em>
and <em>Highlevel preconditions</em>. Action preconditions describe
single actions, like &ldquo;copy a file&rdquo; or &ldquo;execute a
program&rdquo;. Highlevel preconditions can contain other (action)
preconditions and are used for instance for virtualization install
scenarios where hosts and guests are described.

<p><strong>Please note the wording</strong>: A precondition is the particular
YAML block with all the details (think of an object instance). Such a
block is of a &ldquo;precondition type&rdquo; which defines its allowed
structure (think of a class).

<h4 class="subsection">5.4.1 Overview: Action precondition types</h4>

<p>The following <dfn>action</dfn> precondition types are allowed:

     <dl>
<dt><b>package</b><dd>
A package (kernel, library, etc.), of type <em>.tar</em>, <em>.tar.gz</em> or <em>.tar.bz2</em>

     <br><dt><b>image</b><dd>
A complete OS image of type <em>.iso</em>, <em>.tar.gz</em>, <em>.tgz</em>,
<em>.tar</em>, <em>.tar.bz2</em>

     <br><dt><b>prc</b><dd>
Create a config for the <dfn>PRC</dfn> module of the automation layer.

     <br><dt><b>copyfile</b><dd>
One file that can just be copied/rsync'd

     <br><dt><b>installer_stop</b><dd>
Don't reboot machine after system installer finished

     <br><dt><b>grub</b><dd>
Overwrite automatically generated grub config with one provided by the tester

     <br><dt><b>fstab</b><dd>
Append a line to /etc/fstab

     <br><dt><b>repository</b><dd>
Fetch data from a git, hg or svn repository

     <br><dt><b>exec</b><dd>
Execute a script during installation phase

     <br><dt><b>reboot</b><dd>
Requests a reboot test and states how often to reboot.

</dl>

<h4 class="subsection">5.4.2 Overview: Highlevel precondition types</h4>

<p>Currently only the following <dfn>high level</dfn> precondition type is
allowed:

     <dl>
<dt><b>virt</b><dd>
Generic description for Xen or KVM

</dl>

<p><em>High level preconditions</em> both define stuff and can also contain
other preconditions.

<p>They are handled with some effort to <em>Do The Right Thing</em>, i.e.,
a defined root image in the high level precondition is always
installed first. All other preconditions are installed in the order
defined by its tree structure (depth-first).

<h3 class="section">5.5 Details: Precondition Types</h3>

<p>We describe preconditions in YAML files (<a href="http://www.yaml.org/">http://www.yaml.org/</a>).

<p>All preconditions have at least a key

<pre class="verbatim">precondition_type: TYPE
</pre>

<p>and optionally

<pre class="verbatim">name: VERBOSE DESCRIPTION
shortname: SHORT DESCRIPTION
</pre>

<p>then the remaining keys depend on the TYPE.

<h4 class="subsection">5.5.1 installer_stop</h4>

<p>stop run after system installer

<pre class="verbatim">---
precondition_type: installer_stop
</pre>

<h4 class="subsection">5.5.2 grub</h4>

<p>overwrite automatically generated grub config

<pre class="verbatim">---
precondition_type: grub
config: |
  title Linux
    root $grubroot
    kernel /boot/vmlinuz root=$root"
</pre>

     <ul>
<li>Note: multiple lines in the grub file have to be given as one line separated by C&lt;\n&gt; in YAML

     <li>the variables $grubroot and $root are substituted with grub and /dev/* notation of the root partition respectively

     <li>$root substitution uses the notation of the installer kernel. This may cause issues when the installer detects /dev/sd? and the kernel under test detects /dev/hd? or vice versa

     <li>since grub always expects parentheses around the device, they are part of the substitution string for $grubroot

     <li>note the syntax, to get multiline strings in YAML you need to start them with | and a newline

</ul>

<h4 class="subsection">5.5.3 package</h4>

<pre class="verbatim">---
precondition_type: package
filename: /data/artemis/live/repository/packages/linux/linux-2.6.27.7.tar.bz2
</pre>

     <ul>
<li>path names can be absolut or relative to
 /data/artemis/development/repository/packages/

     <li>supported packages types are rpm, deb, tar, tar.gz and tar.bz2

     <li>package type is detected automatically

     <li>absolute path: usually /data/artemis/...

     <li>relative path: relative to /data/artemis/(live|development)/

</ul>

<h4 class="subsection">5.5.4 copyfile</h4>

<p>a file that just needs to be scp or copied:

<pre class="verbatim">---
precondition_type: copyfile
protocol: nfs
source: osko:/export/image_files/official_testing/README
dest: /usr/local/share/artemis/
</pre>

     <ul>
<li>supported protocols are &ldquo;scp&rdquo;, &ldquo;nfs&rdquo; and &ldquo;local&rdquo;

     <li>the part before the first colon in the unique name is used as server name

     <li>the server name part is ignored for local

     <li>if dest ends in a slash, the file is copied with its basename preserved into the denoted directory

     <li>whether the &ldquo;dest&rdquo; is interpreted as a directory or a file is decided by the underlying &ldquo;scp&rdquo; or &ldquo;cp&rdquo; semantics, i.e., it depends on whether a directory already exists.

</ul>

<h4 class="subsection">5.5.5 fstab</h4>

<p>a line to add to /etc/fstab, e.g., to enable mounts once the system boots

<pre class="verbatim">---
precondition_type: fstab
line: "165.204.85.14:/vol/osrc_vol0 /home nfs auto,defaults 0 0"
</pre>

<h4 class="subsection">5.5.6 image</h4>

<p>usually the root image that is unpacked to a partition
(this is in contrast to a guest file that's just there)

<pre class="verbatim">---
precondition_type: image
mount: /
partition: testing
image: /data/artemis/live/repository/images/rhel-5.2-rc2-32bit.tgz
</pre>

     <ul>
<li>partition and mount are required, all other options are optional

     <li>mount points are interpreted as seen inside the future installed system

     <li>if no image is given, the already installed one is reused, i.e., only the mountpoint is mounted; make sure this is possible or your test will fail!

     <li>can be either an iso file which is copied with dd or a tar, tar.gz or
 tar.bz2 package which is unpacked into the partition

     <li>partitions are formated ext3 (only when image is given)
and mounted to mount afterwards

     <p>(this is why image exists at all, copyfile does not provide this)

     <li>&ldquo;image&rdquo;: absolute or relative path (relative to /data/artemis/live/repository/images/)

     <p>If not given, then it re-uses the partition without formatting/unpacking it.

     <li>partition: Can be /dev/XXX or LABEL or UUID.

</ul>

<h4 class="subsection">5.5.7 repository</h4>

<pre class="verbatim">---
precondition_type: repository
type: git
url: git://git.kernel.org/pub/scm/linux/kernel/git/avi/kvm.git
target: kvm
revision: c192a1e274b71daea4e6dd327d8a33e8539ed937
</pre>

     <ul>
<li>git and hg are supported

     <li>type and url are mandatory, target and revision are optional

     <li>target denotes the directory where the source is placed in,
the leading slash can be left out (i.e., paths can be given relative
to root directory &lsquo;<samp><span class="samp">/</span></samp>&rsquo;).

</ul>

<h4 class="subsection">5.5.8 type: prc</h4>

<p>Is typically contained implicitely with the abstract precondition
<em>virt</em>. But can also be defined explicitely, e.g., for kernel
tests.

<p>Creates config for PRC. This config controls what is to be run and
started when the machine boots.

<pre class="verbatim">precondition_type: prc
config:
     runtime: 30
     test_program: /bin/uname_tap.sh
     timeout_after_testprogram: 90
     guests:
      - svm:  /xen/images/..../foo.svm
      - svm:  /xen/images/..../bar.svm
      - exec: /xen/images/..../start_a_kvm_guest.sh
</pre>

     <ul>
<li>guest number

     <p>If it is a guest, for host system use 0.

     <li>test_program

     <p>startet after boot by the PRC

     <li>runtime

     <p>The wanted time, how long it runs, in seconds, this value will be used
to set an environment variable <code>ARTEMIS_TS_RUNTIME</code>, which is
used by the test suite wrappers.

     <li>timeout_testprogram

     <p>Time that the testprogram is given to run, at most, after that it is
killed (SIGINT, SIGKILL).

     <li>guests

     <p>Only used for virtualization tests. Contains an array, one entry per
guest which defines how a guest is started. Can be a SVM file for Xen
or an executable for KVM.

<h4 class="subsection">5.5.9 type: exec</h4>

     <p>Defines which program to run at the installation phase.

     <pre class="verbatim">     precondition_type: exec
     filename: /bin/some_script.sh
     options:
       - -v
       - --foo
       - --bar="hot stuff"
</pre>

     <p>The quotes in this example are actually wrong but left in so you learn
the following lesson:

<h4 class="subsection">5.5.10 type: hint</h4>

     <p>Such a precondition provides hints where normal behaviour needs to be
changd. It contains any hash keys needed for the special handling. The
special handling itself is done in the MCP and needs to be prepared
for what you specify here.

     <p>We currently use it to handle SimNow testing.

     <pre class="verbatim">     precondition_type: hint
     simnow: 1
     script: family10_sles10_xen.simnow
</pre>

<h4 class="subsection">5.5.11 quote subtleties</h4>

     <p>Please note some subtlety about quotes.

          <ul>
<li>This is YAML. And YAML provides its own way of quoting.

          <p>So this

          <pre class="verbatim">          precondition_type: exec
          filename: /bin/some_script.sh
          options:
            - --foo
     </pre>

          <p>and this

          <pre class="verbatim">          precondition_type: exec
          filename: /bin/some_script.sh
          options:
            - "--foo"
     </pre>

          <p>are actually the same (the value is always: <code>--foo</code>) because
quotes at the beginning and end of a YAML line are used by YAML. When
you use quotes at other places like in

          <pre class="verbatim">          precondition_type: exec
          filename: /bin/some_script.sh
          options:
            - --bar="hot stuff"
     </pre>

          <p>then they are not part of the YAML line but part of the value, so this
time the value is: <code>--bar="hot stuff"</code>.

          <li>Quotes are not shell quotes.

          <p>So if you used quotes and they are not YAML quotes but part of the
value then you should know that they are <strong>not</strong> evaluated by a
shell when <code>some_script.sh</code> is called, because we use
<code>system()</code> without a shell layer to start it.

          <p>That's why in above example the quoted value <code>"hot stuff"</code> (with
quotes!) is given as parameter <code>--bar</code> to the program. This
usually <strong>not</strong> what you want.

          <li>Summary: Yo nearly never need quotes.

          <p>This is good enough:

          <pre class="verbatim">          precondition_type: exec
          filename: /bin/some_script.sh
          options:
            - -v
            - --foo
            - --bar=hot stuff
     </pre>

     </ul>

<h4 class="subsection">5.5.12 type: reboot</h4>

     <p>Requests a reboot test and states how often to reboot.

     <p><strong>Note:</strong> Reboot count of 1 actually means boot two times since
the first boot is always counted as number 0.

     <pre class="verbatim">     precondition_type: reboot
     count: 2
</pre>

<h4 class="subsection">5.5.13 type: autoinstall</h4>

     <p>Install a system using autoinstall scripts. The filename denotes the
grub config to be used. It is mandatory and can be given as absolut
path or relative to /data/artemis/.../repository/install_grub/. The
optional timeout is measured in second. If its absent a default value
is used.

     <pre class="verbatim">     precondition_type: autoinstall
     filename: suse/SLES10SP3_x86_64.lst
     timeout: 1800
</pre>

<h4 class="subsection">5.5.14 type: testprogram</h4>

     <p>Define which test program to run. This way of defining a test program
should be prefered to using the <strong>PRC</strong> type precondition. Only the
<strong>testprogram</strong> precondition guarantees parsing that sets all
internal Artemis variables correctly.

     <pre class="verbatim">     precondition_type: testprogram
     runtime: 30
     program: /bin/uname_tap.sh
     timeout: 90
     parameters:
     - --verbose
</pre>

<h4 class="subsection">5.5.15 type: virt</h4>

     <p>A virtualization environment.

     <pre class="verbatim">     name: automatically generated Xen test
     precondition_type: virt
     host:
       preconditions:
       - filename: /data/artemis/live/repository/packages/xen/builds/x86_64/xen-3.3-testing/xen-3.3-testing.2009-03-20.18614_f54cf790ffc7.x86_64.tgz
         precondition_type: package
       - filename: /data/artemis/live/repository/packages/artemisutils/sles10/xen_installer_suse.tar.gz
         precondition_type: package
       - filename: /bin/xen_installer_suse.pl
         precondition_type: exec
       root:
         precondition_type: image
         partition: testing
         image: /data/artemis/live/repository/images/suse/suse_sles10_64b_smp_raw.tar.gz
         mount: /
         arch: linux64
       testprogram:
         execname: /opt/artemis/bin/artemis_testsuite_dom0_meta.sh
         timeout_testprogram: 10800
     guests:
     - config:
         precondition_type: copyfile
         protocol: nfs
         name: artemis:/data/artemis/live/repository/configs/xen/001-sandschaki-1237993266.svm
         dest: /xen/images/
         svm: /xen/images/001-sandschaki-1237993266.svm
       root:
         precondition_type: copyfile
         protocol: nfs
         arch: linux64
         name: osko:/export/image_files/official_testing/redhat_rhel4u7_64b_up_qcow.img
         dest: /xen/images/
         mountfile: /xen/images/001-sandschaki-1237993266.img
         mounttype: raw
       testprogram:
         execname: /opt/artemis/bin/py_ltp
         timeout_after_testprogram: 10800
</pre>

          <ul>
<li>guest root always needs to name the file to mount since
its not easy or even impossible to get this name for some ways to install
the root image (like tar.gz packages or subdir)

          <li>guest root and guest config are installed inside the host,
guest preconditions are installed inside the guest image

          <li>guests can be started with xm create $xenconf, evaluation of
$kvmconf or executing the $execconf script, thus only one of these
three must be provided

     </ul>

     <li>&rdquo;'Note&rdquo;': virt instead of virtualisation is used to reduce
confusion for users whether British English (virtualisation) or
American English (virtualization) is expected

     <li>key &ldquo;arch&rdquo;
 arch: linux64 | linux32             (needed for for artemis toolchain)

</ul>

<h4 class="subsection">5.5.16 General precondition keys &ldquo;mountfile&rdquo;</h4>

<p>These 2 options are possible in each precondition. With that you can
execute the precondition inside guest images:

<pre class="verbatim">mountfile: ...
mountpartition: ...
mounttype: @TODO{is this the same as mountfile, mountpartition?}
</pre>

<p>- 1. only mountfile: eg. rawimage, file loop-mounted
- 2. only mountpartition: then mount that partition
- 3. image file with partitions: mount the imagefile and from that only the given partition

<ul class="menu">
<li><a accesskey="1" href="#Macro-Preconditions">Macro Preconditions</a>
</ul>

<div class="node">
<a name="Macro-Preconditions"></a>
<p><hr>
Up:&nbsp;<a rel="up" accesskey="u" href="#Preconditions">Preconditions</a>

</div>

<h3 class="section">5.6 Macro Preconditions</h3>

<p>This section describes macro precondition files as they are stored in
<code>/data/artemis/live/repository/macropreconditions/</code>.

<p>A macro precondition denotes a file containing one or multiple
preconditions and additional TemplateToolkit code.

<p>In most cases &ldquo;normal preconditions&rdquo; for similar tests will only
differ in one or very few keys. Thus precondition files could easily
be reused by only changing these few keys. This is made easier with
using &ldquo;macro preconditions&rdquo;.

<p>The macro precondition file should contain all &ldquo;normal
preconditions&rdquo; to be reused. All variable keys should be substituted
by appropriate TemplateToolkit variables. When creating the new
testrun actual values for these TemplateToolkit variables have to
provided.

<p>Macro preconditions are <strong>not</strong> stored in the database. They are
only a tool to ease the creation of preconditions. Only the
<strong>resulting</strong> preconditions are stored in database.

<p>To make parsing macro preconditions easier required and optional
fields can be named after a comment field in the first lines of the
file after the keys <code>artemis-mandatory-fields</code> and
<code>artemis-optional-fields</code> respectively as in the following example:

<pre class="verbatim"># artemis-mandatory-fields: id
# artemis-optional-fields: kernel
</pre>

<p>These <code># artemis-*</code> headers are also used in web frontend to
render forms out of it and submit testruns from there.

<p>The values for the placeholders can be filled via such a command line:

<pre class="verbatim"> $ artemis-testrun new [all usual options] \
      --macroprecond=FILENAME \
       -Did=value1 \
       -Dkernel=2.6.37
</pre>

<p>The FILENAME is a complete filename with absolute path.

<p>There is no restriction on TemplateToolkit code for variable
substitution. The following example could be used to generate a
default value for the precondition key id.

<pre class="verbatim">[% id = BLOCK %][% IF id %][% id %][%ELSE%]2009-06-29-perfmon[% END %][% END %]
</pre>

<ul class="menu">
<li><a accesskey="1" href="#A-real-live-example-_002d-kernel-boot-test">A real live example - kernel boot test</a>
</ul>

<div class="node">
<a name="A-real-live-example---kernel-boot-test"></a>
<a name="A-real-live-example-_002d-kernel-boot-test"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Macro-Preconditions">Macro Preconditions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Macro-Preconditions">Macro Preconditions</a>

</div>

<h4 class="subsection">5.6.1 A real live example - kernel boot test</h4>

     <ul>
<li>Macroprecondition

     <pre class="verbatim">     # artemis-mandatory-fields: kernel_version
     # artemis-optional-fields: kernelpkg
     ---
     arch: linux64
     image: suse/suse_sles10_64b_smp_raw.tar.gz
     mount: /
     partition: testing
     precondition_type: image
     ---
     precondition_type: copyfile
     name: /data/artemis/live/repository/testprograms/uname_tap/uname_tap.sh
     dest: /bin/
     protocol: local
     ---
     precondition_type: copyfile
     name: /data/artemis/live/repository/packages/artemisutils/kernel/gen_initrd.sh
     dest: /bin/
     protocol: local
     ---
     [% kernelpkg = BLOCK %]\
     [% IF kernelpkg %]\
     [% kernelpkg %]\
     [%ELSE%]kernel/linux-[% kernel_version %].tar.gz[% END %]\
     [% END %]
     precondition_type: package
     filename: [% kernelpkg %]
     ---
     precondition_type: exec
     filename: /bin/gen_initrd.sh
     options:
       - [% kernel_version %]
     ---
     precondition_type: prc
     config:
           runtime: 30
           test_program: /bin/uname_tap.sh
           timeout_testprogram: 90
</pre>

     <li>The test script

     <p>The test script <code>uname_tap.sh</code> to which the macro precondition
refers is just a shell script that examines uname output:

     <pre class="verbatim">     #! /bin/sh
     echo "1..2"
     echo "# Artemis-Suite-Name: Kernel-Boot"
     echo "# Artemis-Suite-Version: 1.00"
     echo "# Artemis-Machine-Name: " `hostname`
     
     if [ x`uname` != xLinux ] ; then echo -n "not " ; fi
     echo "ok - We run on Linux"
     
     if uname -a | grep -vq x86_64 ; then echo -n "not " ; fi
     echo "ok - Looks like x86_64"
</pre>

     <li>Command line

     <p>Once you wrote the macro precondition and the test script all you need
is this command line:

     <pre class="verbatim">     artemis-testrun new \
       --hostname=dickstone \
       --macroprecond \
         /data/artemis/live/repository/macropreconditions/kernel/kernel_boot.mpc \
        -Dkernelpkg=perfmon-682-x86_64.tar.gz \
        -Dkernel_version=2.6.28-rc3
</pre>

     <p>or with some more information (owner, topic):

     <pre class="verbatim">     artemis-testrun new \
       --owner=mhentsc3 \
       --topic=Kernel \
       --hostname=dickstone \
       --macroprecond \
         /data/artemis/live/repository/macropreconditions/kernel/kernel_boot.mpc \
        -Dkernelpkg=perfmon-682-x86_64.tar.gz \
        -Dkernel_version=2.6.28-rc3
</pre>

</ul>

<h3 class="section">5.7 Precondition Producers</h3>

<p>Sometimes, parameters for preconditions shall be defined when the
testrun, this precondition is assigned to, is choosen for
execution. This might apply for example when you want to test the
newest build of a certain package. Also in combination with autorerun
testruns dynamic assignment of preconditions is useful. These testruns
are reinserted into the database automatically as soon as the
scheduler chooses them for execution. In this case dynamic
precondition assignment allows these rerun tests to differ
slightly. Preconditions with dynamically assigned parameters are
called <dfn>Lazy Precondition</dfn>.

<p>Dynamic precondition assignment is implemented using <dfn>Precondition
Producers</dfn>. A producer is a modul that is called by the scheduler for
handling of lazy preconditions. To use a lazy preconditio the user has
to assign a precondition of type &lsquo;<samp><span class="samp">producer</span></samp>&rsquo; to the testrun. This
precondition has to contain the basename of an existing producer
module and may contain additional parameters. The producer will
substitute the &lsquo;<samp><span class="samp">producer</span></samp>&rsquo; precondition with a normal precondition
that has values assigned to all parameters.

<h4 class="subsection">5.7.1 Lazy precondition</h4>

<p>Lets assume for example that you want to include the newest kernel
package into your test. This can be achieved with the existing
&ldquo;Kernel&rdquo; producer. Instead of a precondition of type &lsquo;<samp><span class="samp">package</span></samp>&rsquo;
with a certain filename you should assign the following precondition
to your testrun.

<pre class="verbatim">precontition_type: producer
producer: Kernel
</pre>

<p>This precondition will be substituted with a package precondition that
has the latest Sysint kernel build set as filename.

<h4 class="subsection">5.7.2 Producer API</h4>

<p>Producer are modules loaded into the scheduler. Thus they need to be
written in Perl and reside inside the
<code>Artemis::MCP::Scheduler::PreconditionProducer::</code> namespace. A
producer has to implement a method &lsquo;<samp><span class="samp">produce</span></samp>&rsquo;. This function gets
a job object as first parameter and a hash containing all additional
options from the precondition as second parameter. It suggested that
each producer inherits from
<code>Artemis::MCP::Scheduler::PreconditionProducer</code>. Producers shall
return a hash that has the produced preconditions as YAML text
assigned to the hash key <code>precondition_yaml</code>. An optional key
<code>topic</code> allows the producer to set the topic for the test. If the
hash key <code>error</code> is set, the associated error string is reported
and the testrun is cancled. In this case the other hash keys are not
evaluated.

<h4 class="subsection">5.7.3 Existing producers</h4>

<p>Currently the following producers exist:

     <ul>
<li>DummyProducer.pm

     <p>Dummy producer for testing.

     <li>Kernel.pm

     <p>Produces preconditions for kernel tests.

     <li>NewestPackage.pm

     <p>Produces a package precondition that installs the newest package from
a given directory.

     <li>SimnowKernel.pm

     <p>Produces preconditions for simnow kernel tests.

     <li>Temare.pm

     <p>Wraps the existing temare producer utility.

</ul>

<h4 class="subsection">5.7.4 Example: &ldquo;Kernel&rdquo; precondition producer</h4>

<p>The kernel producer returns a package precondition that contains the
latest kernel package from the kernel package path. Furthermore, it
returns an exec precondition that triggers the creation of an initrd
file for the kernel.

<p>Valid options:
     <ul>
<li>arch

     <p>May be x86_64 or i686. The latest kernel package from the associated
path are used.

     <li>version

     <p>Only use kernel packages that contain the given version string

     <li>stable

     <p>Use stable kernels when true

</ul>

<h5 class="subsubsection">5.7.4.1 Lazy precondition</h5>

<p>The lazy precondition, pointing to the &ldquo;Kernel&rdquo; precondition
producer:

<pre class="verbatim">precondition_type: produce
producer: Kernel
arch: i686
version: 2.6.32
stable: 1
</pre>

<h5 class="subsubsection">5.7.4.2 Resulting preconditions</h5>

<p>The resulting preconditions may look like this:

<pre class="verbatim">---
filename: kernel/stable/i686/kernel-2.6.32-rc1.tar.gz
precondition_type: package
---
filename: /bin/gen_initrd.sh
options:
  - 2.6.32-rc1
precondition_type: exec
</pre>

<div class="node">
<a name="Command-line-interface"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Web-User-Interface">Web User Interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Preconditions">Preconditions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Command line interface</h2>

<ul class="menu">
<li><a accesskey="1" href="#SYNOPSIS">SYNOPSIS</a>
<li><a accesskey="2" href="#Scheduling">Scheduling</a>
</ul>

<div class="node">
<a name="SYNOPSIS"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Scheduling">Scheduling</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Command-line-interface">Command line interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Command-line-interface">Command line interface</a>

</div>

<h3 class="section">6.1 SYNOPSIS</h3>

     <ul>
<li>Get host usage/scheduling overview

     <li>Create hosts

     <li>Create queues

     <li>Create hosts/queue bindings

</ul>

<div class="node">
<a name="Scheduling"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#SYNOPSIS">SYNOPSIS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Command-line-interface">Command line interface</a>

</div>

<h3 class="section">6.2 Scheduling</h3>

<ul class="menu">
<li><a accesskey="1" href="#Create-new-queue-and-new-host-and-bind-both-together">Create new queue and new host and bind both together</a>
<li><a accesskey="2" href="#Change-queue-priority">Change queue priority</a>
<li><a accesskey="3" href="#requested-features">requested features</a>
<li><a accesskey="4" href="#Cancel-current-testrun-on-host">Cancel current testrun on host</a>
</ul>

<div class="node">
<a name="Create-new-queue-and-new-host-and-bind-both-together"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Change-queue-priority">Change queue priority</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Scheduling">Scheduling</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Scheduling">Scheduling</a>

</div>

<h4 class="subsection">6.2.1 Create new queue and new host and bind both together</h4>

     <ul>
<li>Show existing queues with priorities

     <pre class="verbatim">     artemis@bancroft:~> artemis-testrun listqueue -v
             10 |              AdHoc |  1000
             11 |      kernel_reboot |   100
              4 | xen-3.3-testing-32 |   100
              5 | xen-3.3-testing-64 |   100
              7 | xen-3.4-testing-32 |   100
              6 | xen-3.4-testing-64 |   100
              9 |    xen-unstable-32 |   100
              8 |    xen-unstable-64 |   100
</pre>

     <li>Create new queue <em>oprofile</em>

     <pre class="verbatim">     artemis@bancroft:~> artemis-testrun newqueue --name=oprofile \
                                                  --priority=200
     12
</pre>

     <li>Create new host <em>bullock</em> and bind it to queue <em>oprofile</em>

     <pre class="verbatim">     artemis@bancroft:~> artemis-testrun newhost --name=bullock \
                                                 --queue=oprofile
     10
</pre>

     <li>Show existing hosts

     <p>Note that the new host <em>bullock</em> is initially deactivated.

     <pre class="verbatim">     artemis@bancroft:~> artemis-testrun listhost -v
              8 |  amarok | deactivated |   free
              1 |  athene |      active | in use
              9 |   azael | deactivated |   free
             10 | bullock | deactivated |   free | oprofile
              4 |    cook | deactivated |   free
              6 | incubus | deactivated |   free
              2 |  kobold |      active | in use
              5 |  lemure |      active | in use
              3 |   satyr |      active | in use
              7 |    uruk | deactivated |   free
</pre>

     <li>Activate host <em>bullock</em>

     <p>Note that this command is ID based (bullock has id 10) because you
can rename hosts.

     <pre class="verbatim">     artemis@bancroft:~> artemis-testrun updatehost --id=10 --active
     10 | bullock | active | free | oprofile
</pre>

     <li>Again, show existing hosts

     <p>Host <em>bullock</em> is now activated.

     <pre class="verbatim">     artemis@bancroft:~> artemis-testrun listhost -v
              8 |  amarok | deactivated |   free
              1 |  athene |      active | in use
              9 |   azael | deactivated |   free
             10 | bullock |      active |   free | oprofile
              4 |    cook | deactivated |   free
              6 | incubus | deactivated |   free
              2 |  kobold |      active | in use
              5 |  lemure |      active | in use
              3 |   satyr |      active | in use
              7 |    uruk | deactivated |   free
</pre>

</ul>

<p>Done.

<div class="node">
<a name="Change-queue-priority"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#requested-features">requested features</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Create-new-queue-and-new-host-and-bind-both-together">Create new queue and new host and bind both together</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Scheduling">Scheduling</a>

</div>

<h4 class="subsection">6.2.2 Change queue priority</h4>

     <ul>
<li>List existing queues

     <pre class="verbatim">     artemis@bancroft:~> artemis-testrun listqueue -v
             10 |              AdHoc |  1000
             11 |      kernel_reboot |   100
             12 |           oprofile |   200 | bullock
              4 | xen-3.3-testing-32 |   100
              5 | xen-3.3-testing-64 |   100
              7 | xen-3.4-testing-32 |   100
              6 | xen-3.4-testing-64 |   100
              9 |    xen-unstable-32 |   100
              8 |    xen-unstable-64 |   100
</pre>

     <li>Update queue

     <pre class="verbatim">     artemis@bancroft:~> artemis-testrun updatequeue --name=oprofile \
                                                     --priority=1000
     12
</pre>

     <li>Again, list existing queues

     <pre class="verbatim">     artemis@bancroft:~> artemis-testrun listqueue -v
             10 |              AdHoc |  1000
             11 |      kernel_reboot |   100
             12 |           oprofile |  1000 | bullock
              4 | xen-3.3-testing-32 |   100
              5 | xen-3.3-testing-64 |   100
              7 | xen-3.4-testing-32 |   100
              6 | xen-3.4-testing-64 |   100
              9 |    xen-unstable-32 |   100
              8 |    xen-unstable-64 |   100
</pre>

     <p>Done.

</ul>

<div class="node">
<a name="requested-features"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Cancel-current-testrun-on-host">Cancel current testrun on host</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Change-queue-priority">Change queue priority</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Scheduling">Scheduling</a>

</div>

<h4 class="subsection">6.2.3 requested features</h4>

<p>Hosts for testruns can be choosen based on requested
features. Supported features are:

     <ul>
<li>hostname

     <li>mem

     <li>vendor

     <li>family

     <li>model

     <li>stepping

     <li>revision

     <li>socket

     <li>cores

     <li>clock

     <li>l2cache

     <li>l3cache

</ul>

<div class="node">
<a name="Cancel-current-testrun-on-host"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#requested-features">requested features</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Scheduling">Scheduling</a>

</div>

<h4 class="subsection">6.2.4 Cancel current testrun on host</h4>

<p>Freeing a host need the config for the currently running
testrun. Thus, the command is only tested on bancroft and may not work
on other machines.

<pre class="verbatim">
artemis@bancroft:~> artemis-testrun freehost \
--name=bullock --desc='I need this host right now'

</pre>

<div class="node">
<a name="Web-User-Interface"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reports-API">Reports API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Command-line-interface">Command line interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Web User Interface</h2>

<p>The Web User Interface is a frontend to the Reports database. It
allows to overview reports that came in from several machines, in
several test suites.

<p>It can filter the results by dates, machines or test suite, gives
colorful (RED/YELLOW/GREEN) overview about success/failure ratios,
allows to zoom into details of single reports.

<p>To evaluate reported test results in a more programmatic way, have a
look into the <em>DPath Query Language</em> that is part of the
<a href="#Reports-API">Reports API</a>.

<h3 class="section">7.1 Usage</h3>

<p>The main URL is

<pre class="example">     <a href="http://osrc.amd.com/artemis">http://osrc.amd.com/artemis</a>
</pre>
<h3 class="section">7.2 Understanding Artemis Details</h3>

<h4 class="subsection">7.2.1 Part 1 Overview</h4>

     <ul>
<li>Go to <a href="https://osrc.amd.com/artemis/reports">https://osrc.amd.com/artemis/reports</a>

     <li>Click &ldquo;Last weeks test reports&rdquo;,
  aka. <a href="https://osrc.amd.com/artemis/reports/date/7">https://osrc.amd.com/artemis/reports/date/7</a>

     <li>Below day &ldquo;Wed Oct 7, 2009&rdquo; find the line

     <pre class="verbatim">         20856  2009-10-07  Topic-xen-unstable  satyr  PASS testrun 9617
</pre>

     <p>To find this report you probably need to go more back into the past
  than just 7 days, or you use the direct link below.

     <li>Note that there are other reports in this group that are greyed-out,
  i.e. all report ids of this testrun are:

     <pre class="verbatim">         20856    Topic-xen-unstable
         20855    LMBench
         20854    CTCS
         20852    Host-Overview
         20851    Hardwaredb Overview
</pre>

     <li>Note that something FAILed in the CTCS run (20854).

     <li>What we know until here:

          <ul>
<li>It is a test for Xen-unstable (Topic-xen-unstable)

          <li>The running of the guests+suites itself worked well (20856 PASS)

          <li>There were 2 guest runs:

          <pre class="verbatim">                  LMBench      satyr:celegorm.osrc.amd.com     PASS
                  CTCS         satyr:eriador                   FAIL
     </pre>

     </ul>

     <li>Click on the ID link &ldquo;20856&rdquo;
  aka. <a href="https://osrc.amd.com/artemis/reports/id/20856">https://osrc.amd.com/artemis/reports/id/20856</a>

</ul>

<h4 class="subsection">7.2.2 Part 2 Details</h4>

     <ul>
<li>Here you see the details of this report 20856.

     <p>You see:

          <ul>
<li>green PASSED results for the &ldquo;MCP overview&rdquo;. 
      This means the starting and finishing of the guests worked.

          <li>attachments of console logs.

          <li>some links to more information (raw TAP report, preconditions)

     </ul>

     <li>Note below the group of all the other reports, again it's the group
  of those IDs:

     <pre class="verbatim">         20856    Topic-xen-unstable
         20855    LMBench
         20854    CTCS
         20852    Host-Overview
         20851    Hardwaredb Overview
</pre>

     <li>The most meta information is in &ldquo;20852 Host-Overview&rdquo;.

     <li>Click on the ID link &ldquo;20852&rdquo;
  aka. <a href="https://osrc.amd.com/artemis/reports/id/20852">https://osrc.amd.com/artemis/reports/id/20852</a>

     <li>Now you see the details of &ldquo;20852 Host-Overview&rdquo; with
lots of meta information as &ldquo;Context&rdquo;.

     <p>You see:

     <pre class="verbatim">       Metainfo
           cpuinfo: 	1x Family: 15, Model: 67, Stepping: 2
           ram: 	3950 MB
           uptime: 	0 hrs
     
       XEN-Metainfo
           xen_dom0_kernel: 	2.6.18.8-xen x86_64
           xen_base_os_description: 	SUSE Linux Enterprise Server 10 SP2 (x86_64)
           xen_changeset: 	20273:10cfcbef68ee
           xen_version: 	3.5-unstable
     
       guest_1_redhat_rhel5u4_32bpae_qcow
           xen_guest_description: 	001-lmbench
           xen_guest_flags: 	
           xen_guest_start: 	
     
       guest_2_suse_sles10_sp3_gmc_32b_up_qcow
           xen_guest_description: 	002-ctcs
           xen_guest_flags: 	
           xen_guest_start: 	
</pre>

     <li>If you are interested in what went wrong in the CTCS run,
  click on ID link &ldquo;20854&rdquo;
  aka. <a href="https://osrc.amd.com/artemis/reports/id/20854">https://osrc.amd.com/artemis/reports/id/20854</a>

     <li>Here you see

          <ul>
<li>one RED bar in CTCS-results

          <li>several RED bars in var_log_messages

     </ul>

     <p>You can click on them to unfold the details.

</ul>

<h4 class="subsection">7.2.3 Part 3 Testrun</h4>

     <ul>
<li>Imagine that the testrun completely failed and no usable reports
  arrived in, except that primary one from the MCP, then you can use the
  link at the end of the line

     <pre class="verbatim">         20856  2009-10-07  Topic-xen-unstable  satyr  PASS testrun 9617
                                                            ------------ 
</pre>

     <li>Click on that link &ldquo;testrun 9617&rdquo;
  aka. <a href="https://osrc.amd.com/artemis/testruns/id/9617">https://osrc.amd.com/artemis/testruns/id/9617</a>

     <li>That contains the description what was <strong>planned</strong>
in this testrun, regardless of whether it succeeded.

     <p>(That's the main difference between the two complementary concepts
&ldquo;Testrun&rdquo; vs. &ldquo;Reports&rdquo;. The &ldquo;Testrun&rdquo; contains the
specification, the &ldquo;Reports&rdquo; contain the results.)

     <p>You see:

     <pre class="verbatim">       Name                  Automatically generated Xen test
       Host
           Architecture      linux64
           Root image        /suse_sles10_sp2_64b_smp_raw.tar.gz
           Test              metainfo
       Guest number 1
           Architecture      linux32
           Root image        /redhat_rhel5u4_32bpae_qcow.img
           Test              py_lmbench
       Guest number 2
           Architecture 	linux32
           Root image 	/suse_sles10_sp3_gmc_32b_up_qcow.img
           Test              py_ctcs
</pre>

     <li>That's it, basically.

</ul>

<div class="node">
<a name="Reports-API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Complete-Use-Cases">Complete Use Cases</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Web-User-Interface">Web User Interface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Reports API</h2>

<ul class="menu">
<li><a accesskey="1" href="#Overview">Overview</a>
<li><a accesskey="2" href="#Raw-API-Commands">Raw API Commands</a>
<li><a accesskey="3" href="#Query-language-DPath">Query language DPath</a>
<li><a accesskey="4" href="#Client-Utility-artemis_002dapi">Client Utility artemis-api</a>
</ul>

<!-- ====================================================================== -->
<div class="node">
<a name="Overview"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Raw-API-Commands">Raw API Commands</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reports-API">Reports API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reports-API">Reports API</a>

</div>

<h3 class="section">8.1 Overview</h3>

<p>There runs yet another daemon, the so called
<code>Artemis::Reports::API</code>, on the same host where already the
<code>TAP Receiver</code> runs. This &lsquo;<samp><span class="samp">Reports API</span></samp>&rsquo; is meant for
everything that needs more than just dropping TAP reports to a port,
e.g., some interactive dialog or parameters.

<p>This <code>Artemis::Reports::API</code> listens on Port <code>7358</code>. Its API
is modeled after classic unix script look&amp;feel with a first line
containing a description how to interpret the rest of the lines.

<p>The first line consists of a shebang (<code>#!</code>), a <dfn>api command</dfn>
and <dfn>command parameters</dfn>. The rest of the file is the
<dfn>payload</dfn> for the <dfn>api command</dfn>.

<p>The syntax of the &lsquo;<samp><span class="samp">command params</span></samp>&rsquo; varies depending on the
&lsquo;<samp><span class="samp">api command</span></samp>&rsquo; to make each command intuitively useable. Sometimes
they are just positional parameters, sometimes they look like the
start of a HERE document (i.e., they are prefixed with <code>&lt;&lt;</code> as
you can see below).

<!-- ====================================================================== -->
<div class="node">
<a name="Raw-API-Commands"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Query-language-DPath">Query language DPath</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overview">Overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reports-API">Reports API</a>

</div>

<h3 class="section">8.2 Raw API Commands</h3>

<p>In this section the raw API is described. That's the way you can use
without any dependencies except for the minimum ability to talk to a
port, e.g., via <code>netcat</code>.

<p>See section <a href="#artemis_002dapi">artemis-api</a> for how to use a dedicated command line
utility that makes talking to the reports API easier, but is a
dependency that might not be available in your personal test
environment.

<!--  -->
<ul class="menu">
<li><a accesskey="1" href="#upload-aka_002e-attach-a-file-to-a-report">upload aka. attach a file to a report</a>
<li><a accesskey="2" href="#download-_002d-download-a-file-which-is-attached-to-a-report">download - download a file which is attached to a report</a>
<li><a accesskey="3" href="#mason-_002d-Render-templates-with-embedded-query-language">mason - Render templates with embedded query language </a>
</ul>

<div class="node">
<a name="upload-aka.-attach-a-file-to-a-report"></a>
<a name="upload-aka_002e-attach-a-file-to-a-report"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#download-_002d-download-a-file-which-is-attached-to-a-report">download - download a file which is attached to a report</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Raw-API-Commands">Raw API Commands</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Raw-API-Commands">Raw API Commands</a>

</div>

<h4 class="subsection">8.2.1 upload aka. attach a file to a report</h4>

<p>This api command lets you upload files, aka. attachments, to
reports. These files are available later through the web
interface. Use this to attach log files, config files or console
output.

<ul class="menu">
<li><a accesskey="1" href="#upload-_002d-Synopsis">upload - Synopsis</a>
<li><a accesskey="2" href="#Parameters">Parameters</a>
<li><a accesskey="3" href="#upload-Payload">upload Payload</a>
<li><a accesskey="4" href="#upload-Example-usage">upload Example usage</a>
</ul>

<div class="node">
<a name="upload---Synopsis"></a>
<a name="upload-_002d-Synopsis"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Parameters">Parameters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#upload-aka_002e-attach-a-file-to-a-report">upload aka. attach a file to a report</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#upload-aka_002e-attach-a-file-to-a-report">upload aka. attach a file to a report</a>

</div>

<h5 class="subsubsection">8.2.1.1 upload - Synopsis</h5>

<pre class="verbatim">#! upload REPORTID FILENAME [ CONTENTTYPE ]
payload
</pre>

<div class="node">
<a name="Parameters"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#upload-Payload">upload Payload</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#upload-_002d-Synopsis">upload - Synopsis</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#upload-aka_002e-attach-a-file-to-a-report">upload aka. attach a file to a report</a>

</div>

<h5 class="subsubsection">8.2.1.2 Parameters</h5>

     <ul>
<li>REPORTID

     <p>The id of the report to which the file is assigned

     <li>FILENAME

     <p>The name of the file

     <li>CONTENTTYPE

     <p>Optional MIME type; defaults to <code>plain</code>; use
<code>application/octet-stream</code> to make it downloadable later in
browser.

</ul>

<div class="node">
<a name="upload-Payload"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#upload-Example-usage">upload Example usage</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Parameters">Parameters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#upload-aka_002e-attach-a-file-to-a-report">upload aka. attach a file to a report</a>

</div>

<h5 class="subsubsection">8.2.1.3 upload Payload</h5>

<p>The raw content of the file to upload.

<div class="node">
<a name="upload-Example-usage"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#upload-Payload">upload Payload</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#upload-aka_002e-attach-a-file-to-a-report">upload aka. attach a file to a report</a>

</div>

<h5 class="subsubsection">8.2.1.4 upload Example usage</h5>

<p>Just <code>echo</code> the first api-command line and then immediately
<code>cat</code> the file content:

<pre class="verbatim">$ ( echo "#! upload 552 xyz.tmp" ; cat xyz.tmp ) | netcat -w1 bascha 7358
</pre>

<!--  -->
<div class="node">
<a name="download---download-a-file-which-is-attached-to-a-report"></a>
<a name="download-_002d-download-a-file-which-is-attached-to-a-report"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mason-_002d-Render-templates-with-embedded-query-language">mason - Render templates with embedded query language</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#upload-aka_002e-attach-a-file-to-a-report">upload aka. attach a file to a report</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Raw-API-Commands">Raw API Commands</a>

</div>

<h4 class="subsection">8.2.2 download - download a file which is attached to a report</h4>

<p>This api command lets you download files, aka. attachments, from
reports.

<ul class="menu">
<li><a accesskey="1" href="#download-Synopsis">download Synopsis</a>
<li><a accesskey="2" href="#download-Parameters">download Parameters</a>
<li><a accesskey="3" href="#download-Example-usage">download Example usage</a>
</ul>

<div class="node">
<a name="download-Synopsis"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#download-Parameters">download Parameters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#download-_002d-download-a-file-which-is-attached-to-a-report">download - download a file which is attached to a report</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#download-_002d-download-a-file-which-is-attached-to-a-report">download - download a file which is attached to a report</a>

</div>

<h5 class="subsubsection">8.2.2.1 download Synopsis</h5>

<pre class="verbatim">#! upload REPORTID FILENAME
</pre>

<p>There is no other payload neccessary here, just this single line.

<div class="node">
<a name="download-Parameters"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#download-Example-usage">download Example usage</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#download-Synopsis">download Synopsis</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#download-_002d-download-a-file-which-is-attached-to-a-report">download - download a file which is attached to a report</a>

</div>

<h5 class="subsubsection">8.2.2.2 download Parameters</h5>

     <ul>
<li>REPORTID

     <p>The id of the report to which the file is assigned

     <li>FILENAME

     <p>The name of the file as it was specified on upload

</ul>

<div class="node">
<a name="download-Example-usage"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#download-Parameters">download Parameters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#download-_002d-download-a-file-which-is-attached-to-a-report">download - download a file which is attached to a report</a>

</div>

<h5 class="subsubsection">8.2.2.3 download Example usage</h5>

<p>Just <code>echo</code> the first api-command line and redirect the answer
into a file.

<pre class="verbatim">$ ( echo "#! download 552 xyz.tmp" ) | netcat -w1 bascha 7358 > xyz.tmp
</pre>

<!--  -->
<div class="node">
<a name="mason---Render-templates-with-embedded-query-language"></a>
<a name="mason-_002d-Render-templates-with-embedded-query-language"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#download-_002d-download-a-file-which-is-attached-to-a-report">download - download a file which is attached to a report</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Raw-API-Commands">Raw API Commands</a>

</div>

<h4 class="subsection">8.2.3 mason - Render templates with embedded query language</h4>

<p>To query report results we provide sending templates to the API in
which you can use a query language to get report details: This
api-command is called like the template engine so that we can provide
other template engines as well.

<ul class="menu">
<li><a accesskey="1" href="#mason-Synopsis">mason Synopsis</a>
<li><a accesskey="2" href="#mason-Parameters">mason Parameters</a>
<li><a accesskey="3" href="#Payload">Payload</a>
<li><a accesskey="4" href="#Example-usage">Example usage</a>
</ul>

<div class="node">
<a name="mason-Synopsis"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mason-Parameters">mason Parameters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mason-_002d-Render-templates-with-embedded-query-language">mason - Render templates with embedded query language</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#mason-_002d-Render-templates-with-embedded-query-language">mason - Render templates with embedded query language</a>

</div>

<h5 class="subsubsection">8.2.3.1 mason Synopsis</h5>

<pre class="verbatim">#! mason debug=0 &lt;&lt;ENDMARKER
payload
ENDMARKER
</pre>

<div class="node">
<a name="mason-Parameters"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Payload">Payload</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mason-Synopsis">mason Synopsis</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#mason-_002d-Render-templates-with-embedded-query-language">mason - Render templates with embedded query language</a>

</div>

<h5 class="subsubsection">8.2.3.2 mason Parameters</h5>

     <ul>
<li>debug=1

     <p>If &lsquo;<samp><span class="samp">debug</span></samp>&rsquo; is specified and value set to 1 then any error message
that might occur is reported as result content. If debug is omitted or
false and an error occurs then the result is just empty.

     <li>&lt;&lt;ENDMARKER

     <p>You can choose any word instead of ENDMARKER which should mark the end
of input, like in HERE documents, usually some word that is not
contained in the template payload.

</ul>

<div class="node">
<a name="Payload"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Example-usage">Example usage</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mason-Parameters">mason Parameters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#mason-_002d-Render-templates-with-embedded-query-language">mason - Render templates with embedded query language</a>

</div>

<h5 class="subsubsection">8.2.3.3 mason Payload</h5>

<p>A mason template.

<p><dfn>Mason</dfn> is a template language, see
<a href="http://masonhq.com">http://masonhq.com</a>. Inside the template we provide a function
<code>reportdata</code> to access report data via a query language. See
section <a href="#Query-language">Query language</a> for details about this.

<div class="node">
<a name="Example-usage"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Payload">Payload</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#mason-_002d-Render-templates-with-embedded-query-language">mason - Render templates with embedded query language</a>

</div>

<h5 class="subsubsection">8.2.3.4 Example usage</h5>

<p>This is a raw Mason template:

<pre class="verbatim"> % my $world = "Mason World";
 Hello &lt;% $world %>!
 % my @res = reportdata '{ "suite.name" => "perfmon" } :: //tap/tests_planned';
 Planned perfmon tests:
 % foreach (@res) {
    &lt;% $_ %>
 % }
</pre>

<p>If you want to submit such a Mason template you can add the
api-command line and the EOF marker like this:

<pre class="verbatim">$ EOFMARKER="MASONTEMPLATE".$$
$ payload_file="perfmon_tests_planned.mas"
$ ( echo "#! mason &lt;&lt;$EOFMARKER" ; cat $payload_file ; echo "$EOFMARKER" ) \
    | netcat -w1 bascha 7358
</pre>

<p>The output of this is the rendered template. You can extend the line
to save the rendered result into a file:

<pre class="verbatim">$ ( echo "#! mason &lt;&lt;$EOFMARKER" ; cat $payload_file ; echo "$EOFMARKER" ) \
    | netcat -w1 bascha 7358 > result.txt
</pre>

<p>The answer for this looks like this:

<pre class="verbatim">Hello Mason World!
Planned perfmon tests:
   3
   4
   17
</pre>

<p><a name="Query-language"></a><div class="node">
<a name="Query-language-DPath"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Client-Utility-artemis_002dapi">Client Utility artemis-api</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Raw-API-Commands">Raw API Commands</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reports-API">Reports API</a>

</div>

<h3 class="section">8.3 Query language DPath</h3>

<p>The query language, which is the argument to the <code>reportdata</code> as
used embedded in the &lsquo;<samp><span class="samp">mason</span></samp>&rsquo; examples above:

<pre class="verbatim"> reportdata '{ "suite.name" => "perfmon" } :: //tap/tests_planned'
</pre>

<p>consists of 2 parts, divided by the &lsquo;<samp><span class="samp">::</span></samp>&rsquo;.

<p>We call the first part in braces <em>reports filter</em> and the second
part <em>data filter</em>.

<ul class="menu">
<li><a accesskey="1" href="#Reports-Filter-_0028SQL_002dAbstract_0029">Reports Filter (SQL-Abstract)</a>
<li><a accesskey="2" href="#Data-Filter">Data Filter</a>
<li><a accesskey="3" href="#Optimizations">Optimizations</a>
</ul>

<div class="node">
<a name="Reports-Filter-(SQL-Abstract)"></a>
<a name="Reports-Filter-_0028SQL_002dAbstract_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Data-Filter">Data Filter</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Query-language-DPath">Query language DPath</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Query-language-DPath">Query language DPath</a>

</div>

<h4 class="subsection">8.3.1 Reports Filter (SQL-Abstract)</h4>

<p>The <em>reports filter</em> selects which reports to look at. The
expression inside the braces is actually a complete
<code>SQL::Abstract</code> expression
(<a href="http://search.cpan.org/~mstrout/SQL-Abstract/">http://search.cpan.org/~mstrout/SQL-Abstract/</a>) working
internally as a <code>select</code> in the context of the object relational
mapper, which targets the table <code>Report</code> with an active JOIN to
the table <code>Suite</code>.

<p>All the matching reports are then taken to build a data structure for
each one, consisting of the table data and the parsed TAP part which
is turned into a data structure via <code>TAP::DOM</code>
(<a href="http://search.cpan.org/~schwigon/TAP-DOM/">http://search.cpan.org/~schwigon/TAP-DOM/</a>).

<p>The <em>data filter</em> works then on that data structure for each
report.

<ul class="menu">
<li><a accesskey="1" href="#SQL_002dAbstract-expressions">SQL-Abstract expressions</a>
<li><a accesskey="2" href="#The-data-structure">The data structure</a>
</ul>

<div class="node">
<a name="SQL-Abstract-expressions"></a>
<a name="SQL_002dAbstract-expressions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-data-structure">The data structure</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reports-Filter-_0028SQL_002dAbstract_0029">Reports Filter (SQL-Abstract)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reports-Filter-_0028SQL_002dAbstract_0029">Reports Filter (SQL-Abstract)</a>

</div>

<h5 class="subsubsection">8.3.1.1 SQL::Abstract expressions</h5>

<p>The filter expressions are best described by example:

     <ul>
<li>Select a report by ID
<pre class="verbatim">     { 'id' => 1234 }
</pre>

     <li>Select a report by suite name
<pre class="verbatim">     { 'suite_name' => 'oprofile' }
</pre>

     <li>Select a report by machine name
<pre class="verbatim">     { 'machine_name' => 'bascha' }
</pre>

     <li>Select a report by date

     <p>Here the value that you want to select is a structure by itself,
consisting of the comparison operator and a time string:

     <pre class="verbatim">     { 'created_at' => { '&lt;', '2009-04-09 10:00' }  }
</pre>

</ul>

<div class="node">
<a name="The-data-structure"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#SQL_002dAbstract-expressions">SQL-Abstract expressions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reports-Filter-_0028SQL_002dAbstract_0029">Reports Filter (SQL-Abstract)</a>

</div>

<h5 class="subsubsection">8.3.1.2 The data structure</h5>

<div class="node">
<a name="Data-Filter"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Optimizations">Optimizations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reports-Filter-_0028SQL_002dAbstract_0029">Reports Filter (SQL-Abstract)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Query-language-DPath">Query language DPath</a>

</div>

<h4 class="subsection">8.3.2 Data Filter</h4>

<p>The data structure that is created for each report can be evaluated
using the <em>data filter</em> part of the query language, i.e.,
everything after the <code>::</code>. This part is passed through to
<code>Data::DPath</code>
(<a href="http://search.cpan.org/~schwigon/Data-DPath/">http://search.cpan.org/~schwigon/Data-DPath/</a>).

<ul class="menu">
<li><a accesskey="1" href="#Data_002dDPath-expressions">Data-DPath expressions</a>
</ul>

<div class="node">
<a name="Data-DPath-expressions"></a>
<a name="Data_002dDPath-expressions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Data-Filter">Data Filter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Data-Filter">Data Filter</a>

</div>

<h5 class="subsubsection">8.3.2.1 Data-DPath expressions</h5>

<div class="node">
<a name="Optimizations"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Data-Filter">Data Filter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Query-language-DPath">Query language DPath</a>

</div>

<h4 class="subsection">8.3.3 Optimizations</h4>

<p>Using the query language can be slow. The biggest slowdown occurs with
the &lsquo;<samp><span class="samp">ANYWHERE</span></samp>&rsquo; element <code>//</code>, again with several of them,
because they span up a big search tree.

<p>Therefore, if you know the depth of your path, try to replace the
<code>//</code> with some <code>*</code> because that only spans up on the current
step not every possible step, like this:

<pre class="verbatim">  { ... } :: //section/stats-proc-interrupts-before//tap//data/TLB";
</pre>

<pre class="verbatim">  { ... } :: /results/*/section/stats-proc-interrupts-before/tap/lines/*/_children/*/data/TLB";
</pre>

<!-- ====================================================================== -->
<p><a name="artemis_002dapi"></a><div class="node">
<a name="Client-Utility-artemis-api"></a>
<a name="Client-Utility-artemis_002dapi"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Query-language-DPath">Query language DPath</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reports-API">Reports API</a>

</div>

<h3 class="section">8.4 Client Utility artemis-api</h3>

<p>There is a command line utility <code>artemis-api</code> that helps with
using the API without the need to talk the protocol and fiddle with
<code>netcat</code> by yourself.

<ul class="menu">
<li><a accesskey="1" href="#help">help</a>
<li><a accesskey="2" href="#upload">upload</a>
<li><a accesskey="3" href="#mason">mason</a>
</ul>

<div class="node">
<a name="help"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#upload">upload</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Client-Utility-artemis_002dapi">Client Utility artemis-api</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-Utility-artemis_002dapi">Client Utility artemis-api</a>

</div>

<h4 class="subsection">8.4.1 help</h4>

<p>You can aquire a help page to each sub command:

<pre class="verbatim">$ /opt/artemis/perl/bin/artemis-api help upload
</pre>

<p>prints

<pre class="verbatim">artemis-api upload --reportid=s --file=s [ --contenttype=s ]
   --verbose          some more informational output
   --reportid         INT; the testrun id to change
   --file             STRING; the file to upload, use '-' for STDIN
   --contenttype      STRING; content-type, default 'plain', 
                      use 'application/octed-stream' for binaries
</pre>

<div class="node">
<a name="upload"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mason">mason</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#help">help</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-Utility-artemis_002dapi">Client Utility artemis-api</a>

</div>

<h4 class="subsection">8.4.2 upload</h4>

<p>Use it from the Artemis path, like:

<pre class="verbatim">$ /opt/artemis/perl/bin/artemis-api upload \
  --file /var/log/messages \
  --reportid=301
</pre>

<p>You can also use the special filename <samp><span class="file">-</span></samp> to read from STDIN,
e.g., if you need to pipe the output of tools like <code>dmesg</code>:

<pre class="verbatim">$ dmesg | /opt/artemis/perl/bin/artemis-api upload \
  --file=- \
  --filename dmesg \
  --reportid=301
</pre>

<div class="node">
<a name="mason"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#upload">upload</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-Utility-artemis_002dapi">Client Utility artemis-api</a>

</div>

<h4 class="subsection">8.4.3 mason</h4>

<p>TODO

<div class="node">
<a name="Complete-Use-Cases"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reports-API">Reports API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Complete Use Cases</h2>

<p>In this chapter we describe how the single features are put together
into whole use-cases.

<h3 class="section">9.1 Automatic Xen testing</h3>

<p>This is a description on how to run Xen tests with Artemis using
<code>SLES10</code> with one <code>RHEL5.2</code> guest (64 bit) as an example.

<p>The following mainly applies to <b>manually</b> assigning Xen tests. In
the OSRC we use <em>temare</em> (not yet published) to automatically
create the here described steps.

<h4 class="subsection">9.1.1 Paths</h4>

     <ul>
<li>Host <strong>bancroft</strong>: /data/bancroft/artemis/live/

     <li>Host <strong>osko</strong>: /export/image_files/official_testing/

</ul>

<h4 class="subsection">9.1.2 Choose an image for Dom0 and images for each guest</h4>

<p>We use suse/suse_sles10_64b_smp_raw.tar.gz as Dom0 and

<pre class="verbatim">
 osko:/export/images/testing/raw/redhat_rhel5u2_64b_smp_up_small_raw.img

</pre>

<p>as the only guest.

<p>The SuSE image is of precondition type image. Thus its path is
relative to <code>/mnt/images</code> which has
<code>bancroft:/data/bancroft/artemis/live/repository/images/</code>
mounted.

<p>The root partition is named in the section &lsquo;<samp><span class="samp">root</span></samp>&rsquo; of the Xen
precondition. Furthermore, you need to define the destination
partition to be Dom0 root. We use <code>/dev/sda2</code> as an example. The
partition could also be named using its UUID or partition label. Thus
you need to add the following to the dom0 part of the Xen precondition:

<pre class="verbatim">
  root: 
    precondition_type: image
    mount: / 
    image: suse/suse_sles10_64b_smp_raw.tar.gz 
    partition: /dev/sda2

</pre>

<p>The RedHat image is of type &lsquo;<samp><span class="samp">copyfile</span></samp>&rsquo;.

<p>It is copied from
<code>osko:/export/image_files/official_testing/raw_img/</code> which is
mounted to <code>/mnt/nfs</code> before.

<p>This mounting is done automatically because the protocol type nfs is
given. The image file is copied to the destination named as dest in
the &lsquo;<samp><span class="samp">copyfile</span></samp>&rsquo; precondition. We use <code>/xen/images/</code> as an
example. To allow the System Installer to install preconditions into
the guest image, the file to mount and the partition to mount need to
be named. Note that even though in some cases, the mountfile can be
determined automatically, in other cases this is not possible
(e.g. when you get it from a tar.gz package). The resulting root
secition for this guest is:

<pre class="verbatim"> 
   root:
     precondition_type: copyfile
     name: osko:/export/images/testing/raw/redhat_rhel5u2_64b_smp_up_small_raw.img
     protocol: nfs
     dest: /xen/images/
     mountfile: /xen/images/redhat_rhel5u2_64b_smp_up_small_raw.img
     mountpartition: p1

</pre>

<h4 class="subsection">9.1.3 PRC configuration</h4>

<p>PRC (Program Run Control) is responsible for starting guests and test
suites.

<h5 class="subsubsection">9.1.3.1 Guest Start Configuration</h5>

<p>Making PRC able to start Xen guests is very simple. Every guest entry
needs to have a section named "config". In this section, a
precondition describing how the config file is installed and a
filename have to be given. As for guest images the file name is needed
because it can't be determined in some cases. We use 001.svm installed
via copyfile to /xen/images/001.svm. The resulting config section is:

<pre class="verbatim"> 
     config:
       precondition_type: copyfile
       name: /usr/share/artemis/packages/mhentsc3/001.svm
       protocol: local
       dest: /xen/images/
       filename: /xen/images/001.svm

</pre>

<h5 class="subsubsection">9.1.3.2 Testsuite Configuration</h5>

<p>You need to define, where you want which test suite to run. This can
be done in every guest and the Dom0. In this example, the Dom0 and the
single guest will run different testsuites. this chapter only
describes the Dom0 test program. See the summary at the end for
details on the guest test program.

<p>The section testprogram consists of a precondition definition
describing how the test suite is installed. In our example we use a
precondition type package with a relative path name. This path is
relative to
&rdquo;'/data/bancroft/artemis/live/repository/packages/&rdquo;'. Since
&rdquo;'bancroft:/data/bancroft/&rdquo;' is mounted to &rdquo;'/data/bancroft/&rdquo;' in
the install system, this directory can be accessed at
&rdquo;'bancroft:/data/bancroft/artemis/live/repository/packages/&rdquo;'.

<p>Beside the precondition you need to define an execname which is the
full path name of the file to be executed (remember, it can't be
determined). This file is called in the root directory (&rdquo;'/&rdquo;') in
the test system thus in case you need to use relative paths inside
your test suite they need to be relative to this. The program may take
parameters which are named in the optional array &rdquo;'parameters&rdquo;' and
taken as is. The parameter is &rdquo;'timeout_after_testprogram&rdquo;' which
allows you to define that your test suite shall be killed (and an
error shall be reported) after that many seconds. Even though this
parameter is optional, leaving it out will result in Artemis waiting
forever if your test doesn't send finish messages. The resulting
testprogram section looks like this:

<pre class="verbatim"> 
   testprogram:
     precondition_type: package
     filename: artemis-testsuite-system.tar.gz
     path: mhentsc3/
     timeout_after_testprogram: ~
     execname: /opt/system/bin/artemis_testsuite_system.sh 
     parameters: 
       - --report

</pre>

<h4 class="subsection">9.1.4 Preconditions</h4>

<p>Usually your images will not have every software needed for your tests
installed. In fact the example images now do but for the purpose of
better explanation we assume that we need to install dhcp, python-xml
and bridge-utils in Dom0. Furthermore we need a script to enable
network and console. At last we install the Xen package and a Xen
installer package. These two are still needed on our test
images. Package preconditions may have a &rdquo;'scripts&rdquo;' array attached
that name a number of programs to be executed after the package was
installed. This is used in our example to call the Xen installer
script after the Xen package and the Xen installer package were
installed. See the summary at the end for the resulting precondition
section.  The guest image only needs a DHCP client. Since this
precondition is appended to the precondition list of the appropriate
guest entry, the System Installer will automatically know that the
guest image has to be mounted and the precondition needs to be
installed inside relative to this mount.

<h4 class="subsection">9.1.5 Resulting YAML config</h4>

<p>After all these informations are gathered, put the following YAML text
into a file. We use /tmp/xen.yml as an example.

<pre class="verbatim"> 
   precondition_type: xen
   name: SLES 10 Xen with RHEL5.2 guest (64 bit)
   dom0:
     root:
       precondition_type: image
       mount: /
       image: suse/suse_sles10_64b_smp_raw.tar.gz
       partition: /dev/sda2
     testprogram:
       precondition_type: package
       filename: artemis-testsuite-system.tar.gz
       path: mhentsc3/
       timeout_after_testprogram: 3600
       execname: /home/artemis/x86_64/bin/artemis_testsuite_ctcs.sh
       parameters: 
         - --report
     preconditions:
       - precondition_type: package
         filename: dhcp-3.0.3-23.33.x86_64.rpm
         path: mhentsc3/sles10/
       - precondition_type: package
         filename: dhcp-client-3.0.3-23.33.x86_64.rpm
         path: mhentsc3/sles10/
       - precondition_type: package
         filename: python-xml-2.4.2-18.7.x86_64.rpm
         path: mhentsc3/sles10/
       - precondition_type: package
         filename: bridge-utils-1.0.6-14.3.1.x86_64.rpm
         path: mhentsc3/sles10/
   # has to come BEFORE xen because config done in here is needed for xens initrd
       - precondition_type: package
         filename: network_enable_sles10.tar.gz
         path: mhentsc3/sles10/
         scripts:
           - /bin/network_enable_sles10.sh
       - precondition_type: package
         filename: xen-3.2_20080116_1546_16718_f4a57e0474af__64bit.tar.gz
         path: mhentsc3/
         scripts: ~
       - precondition_type: package
         filename: xen_installer_suse.tar.gz
         path: mhentsc3/sles10/
         scripts:
           - /bin/xen_installer_suse.pl
   # only needed for debug purpose
       - precondition_type: package
         filename: console_enable.tar.gz
         path: mhentsc3/
         scripts:
           - /bin/console_enable.sh
   guests:
     - root:
         precondition_type: copyfile
         name: osko:/export/images/testing/raw/redhat_rhel5u2_64b_smp_up_small_raw.img
         protocol: nfs
         dest: /xen/images/
         mountfile: /xen/images/redhat_rhel5u2_64b_smp_up_small_raw.img
         mountpartition: p1
         #       mountpartition: /dev/sda3 # or label or uuid
       config:
         precondition_type: copyfile
         name: /usr/share/artemis/packages/mhentsc3/001.svm
         protocol: local
         dest: /xen/images/
         filename: /xen/images/001.svm
       testprogram:
         precondition_type: copyfile
         name: /usr/share/artemis/packages/mhentsc3/testscript.pl
         protocol: local
         dest: /bin/
         timeout_after_testprogram: 100
         execname: /bin/testscript.pl
       preconditions:
         - precondition_type: package
           filename: dhclient-4.0.0-6.fc9.x86_64.rpm
           path: mhentsc3/fedora9/

</pre>

<h4 class="subsection">9.1.6 Grub</h4>

<p>For Xen to run correctly, the defaults grub configuration is not
sufficient. You need to add another precondition to your test. System
Installer will replace <code>$root</code> with the <code>/dev/*</code> notation of
the root partition and <code>$grubroot</code> with the grub notation of the
root partition (including parenthesis). Put the resulting precondition
into a file. We use <code>/tmp/grub.yml</code> as an example. This file may
read like this:

<pre class="verbatim"> 
  precondition_type: grub
  config: |
   serial --unit=0 --speed=115200
   terminal serial
   timeout 3
   default 0
   title XEN-test
     root $grubroot
     kernel /boot/xen.gz com1=115200,8n1 console=com1
     module /boot/vmlinuz-2.6.18.8-xen root=$root showopts console=ttyS0,115200
     module /boot/initrd-2.6.18.8-xen 

</pre>

<h4 class="subsection">9.1.7 Order Testrun</h4>

<p>To order your test run with the previously defined preconditions you
need to stuff them into the database. Fortunatelly there are
commandline tools to help you with this job. They can be found at
<code>/opt/artemis/perl/bin</code>. In our production environment the server
for Artemis is <code>bancroft.amd.com</code>. Log in to this server (as use
<code>artemis</code>). Make sure that <code>$ARTEMIS_LIVE</code> is set to 1 and
<code>/opt/artemis/perl/bin/</code> is at the beginning of your <code>$PATH</code>
(so the correct perl will always be found). For each precondition you
want to put into the database you need to define a short name. Call
<code>/opt/artemis/perl/bin/artemis-testrun newprecondition</code> with the
appropriate options, e.g. in our example:

<pre class="verbatim"> 
 $ /opt/artemis/perl/bin/artemis-testrun newprecondition \
                                         --shortname=grub \
                                         --condition_file=/tmp/grub.yml
 $ /opt/artemis/perl/bin/artemis-testrun newprecondition \
                                         --shortname=xen \
                                         --condition_file=/tmp/xen.yml

</pre>

<p><code>artemis-testrun</code> will return a precondition ID in each case. You
will need those soon so please keep them in mind. In the example the
precondition id for grub is 4 and for Xen its 5.

<p>You can now put your test run into the database using
<code>/opt/artemis/perl/bin/artemis-testrun new</code>. This expects a
hostname, a test program and all preconditions. The test program is
never evaluated and only there for historical reasons. Put in anything
you like. Add <code>--owner</code> with an appropriate user if you don't
want the default <code>artemis</code>. The resulting call looks like this:

<pre class="verbatim">
  /opt/artemis/perl/bin/artemis-testrun new \
                                        --hostname=bullock \
                                        --precondition=4 \
                                        --precondition=5 \
                                        --test_program=whatever \
                                        --owner=mhentsc3
 
</pre>

<p>Please note: There is a more central approach to describe all needed
preconditions at once, see <a href="#Macro-Preconditions">Macro Preconditions</a> and <a href="#A-real-live-example-_002d-kernel-boot-test">A real live example - kernel boot test</a>.

<p>When the requested testrun is scheduledArtemis will setup the system
you requested and execute your defined testrun. When everything went
well, you'll see test output soon after. For more information on what
is going on with Artemis, see <code>/var/log/artemis-debug</code>.

</div><!-- class="artemismanual"-->